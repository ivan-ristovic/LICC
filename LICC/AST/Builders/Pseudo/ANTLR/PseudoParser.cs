#nullable disable
namespace LICC.AST.Builders.Pseudo
{
    //------------------------------------------------------------------------------
    // <auto-generated>
    //     This code was generated by a tool.
    //     ANTLR Version: 4.7.1
    //
    //     Changes to this file may cause incorrect behavior and will be lost if
    //     the code is regenerated.
    // </auto-generated>
    //------------------------------------------------------------------------------

    // Generated from Pseudo.g4 by ANTLR 4.7.1

    // Unreachable code detected
#pragma warning disable 0162
    // The variable '...' is assigned but its value is never used
#pragma warning disable 0219
    // Missing XML comment for publicly visible type or member '...'
#pragma warning disable 1591
    // Ambiguous reference in cref attribute
#pragma warning disable 419

    using System;
    using System.IO;
    using System.Text;
    using System.Diagnostics;
    using System.Collections.Generic;
    using Antlr4.Runtime;
    using Antlr4.Runtime.Atn;
    using Antlr4.Runtime.Misc;
    using Antlr4.Runtime.Tree;
    using DFA = Antlr4.Runtime.Dfa.DFA;

    [System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.7.1")]
    [System.CLSCompliant(false)]
    public partial class PseudoParser : Parser
    {
        protected static DFA[] decisionToDFA;
        protected static PredictionContextCache sharedContextCache = new PredictionContextCache();
        public const int
            T__0 = 1, T__1 = 2, T__2 = 3, T__3 = 4, T__4 = 5, T__5 = 6, T__6 = 7, T__7 = 8, T__8 = 9,
            T__9 = 10, T__10 = 11, T__11 = 12, T__12 = 13, T__13 = 14, T__14 = 15, T__15 = 16, T__16 = 17,
            T__17 = 18, T__18 = 19, T__19 = 20, T__20 = 21, T__21 = 22, T__22 = 23, T__23 = 24,
            T__24 = 25, T__25 = 26, T__26 = 27, T__27 = 28, T__28 = 29, T__29 = 30, T__30 = 31,
            T__31 = 32, T__32 = 33, T__33 = 34, T__34 = 35, T__35 = 36, T__36 = 37, T__37 = 38,
            T__38 = 39, T__39 = 40, T__40 = 41, T__41 = 42, T__42 = 43, T__43 = 44, T__44 = 45,
            T__45 = 46, T__46 = 47, T__47 = 48, T__48 = 49, T__49 = 50, NAME = 51, STRING = 52,
            INT = 53, HEX = 54, FLOAT = 55, HEX_FLOAT = 56, BlockComment = 57, LineComment = 58,
            WS = 59;
        public const int
            RULE_unit = 0, RULE_block = 1, RULE_statement = 2, RULE_declaration = 3,
            RULE_parlist = 4, RULE_assignment = 5, RULE_exp = 6, RULE_aexp = 7, RULE_lexp = 8,
            RULE_aop = 9, RULE_rop = 10, RULE_lop = 11, RULE_uop = 12, RULE_cexp = 13,
            RULE_explist = 14, RULE_literal = 15, RULE_type = 16, RULE_typename = 17,
            RULE_var = 18, RULE_iexp = 19;
        public static readonly string[] ruleNames = {
        "unit", "block", "statement", "declaration", "parlist", "assignment",
        "exp", "aexp", "lexp", "aop", "rop", "lop", "uop", "cexp", "explist",
        "literal", "type", "typename", "var", "iexp"
    };

        private static readonly string[] _LiteralNames = {
        null, "'algorithm'", "'begin'", "'end'", "'pass'", "'return'", "'error'",
        "'if'", "'then'", "'else'", "'while'", "'do'", "'repeat'", "'until'",
        "'increment'", "'decrement'", "'declare'", "'='", "'procedure'", "'('",
        "')'", "'function'", "'returning'", "':'", "','", "'True'", "'False'",
        "'+'", "'-'", "'*'", "'/'", "'div'", "'mod'", "'>'", "'>='", "'<'", "'<='",
        "'=='", "'=/='", "'and'", "'or'", "'not'", "'call'", "'array'", "'list'",
        "'set'", "'integer'", "'real'", "'string'", "'['", "']'"
    };
        private static readonly string[] _SymbolicNames = {
        null, null, null, null, null, null, null, null, null, null, null, null,
        null, null, null, null, null, null, null, null, null, null, null, null,
        null, null, null, null, null, null, null, null, null, null, null, null,
        null, null, null, null, null, null, null, null, null, null, null, null,
        null, null, null, "NAME", "STRING", "INT", "HEX", "FLOAT", "HEX_FLOAT",
        "BlockComment", "LineComment", "WS"
    };
        public static readonly IVocabulary DefaultVocabulary = new Vocabulary(_LiteralNames, _SymbolicNames);

        [NotNull]
        public override IVocabulary Vocabulary {
            get {
                return DefaultVocabulary;
            }
        }

        public override string GrammarFileName { get { return "Pseudo.g4"; } }

        public override string[] RuleNames { get { return ruleNames; } }

        public override string SerializedAtn { get { return new string(_serializedATN); } }

        static PseudoParser()
        {
            decisionToDFA = new DFA[_ATN.NumberOfDecisions];
            for (int i = 0; i < _ATN.NumberOfDecisions; i++) {
                decisionToDFA[i] = new DFA(_ATN.GetDecisionState(i), i);
            }
        }

        public PseudoParser(ITokenStream input) : this(input, Console.Out, Console.Error) { }

        public PseudoParser(ITokenStream input, TextWriter output, TextWriter errorOutput)
        : base(input, output, errorOutput)
        {
            Interpreter = new ParserATNSimulator(this, _ATN, decisionToDFA, sharedContextCache);
        }
        public partial class UnitContext : ParserRuleContext
        {
            public ITerminalNode NAME() { return GetToken(PseudoParser.NAME, 0); }
            public BlockContext block()
            {
                return GetRuleContext<BlockContext>(0);
            }
            public ITerminalNode Eof() { return GetToken(PseudoParser.Eof, 0); }
            public UnitContext(ParserRuleContext parent, int invokingState)
                : base(parent, invokingState)
            {
            }
            public override int RuleIndex { get { return RULE_unit; } }
            public override void EnterRule(IParseTreeListener listener)
            {
                IPseudoListener typedListener = listener as IPseudoListener;
                if (typedListener != null) typedListener.EnterUnit(this);
            }
            public override void ExitRule(IParseTreeListener listener)
            {
                IPseudoListener typedListener = listener as IPseudoListener;
                if (typedListener != null) typedListener.ExitUnit(this);
            }
            public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor)
            {
                IPseudoVisitor<TResult> typedVisitor = visitor as IPseudoVisitor<TResult>;
                if (typedVisitor != null) return typedVisitor.VisitUnit(this);
                else return visitor.VisitChildren(this);
            }
        }

        [RuleVersion(0)]
        public UnitContext unit()
        {
            UnitContext _localctx = new UnitContext(Context, State);
            EnterRule(_localctx, 0, RULE_unit);
            try {
                EnterOuterAlt(_localctx, 1);
                {
                    State = 40; Match(T__0);
                    State = 41; Match(NAME);
                    State = 42; block();
                    State = 43; Match(Eof);
                }
            } catch (RecognitionException re) {
                _localctx.exception = re;
                ErrorHandler.ReportError(this, re);
                ErrorHandler.Recover(this, re);
            } finally {
                ExitRule();
            }
            return _localctx;
        }

        public partial class BlockContext : ParserRuleContext
        {
            public StatementContext[] statement()
            {
                return GetRuleContexts<StatementContext>();
            }
            public StatementContext statement(int i)
            {
                return GetRuleContext<StatementContext>(i);
            }
            public BlockContext(ParserRuleContext parent, int invokingState)
                : base(parent, invokingState)
            {
            }
            public override int RuleIndex { get { return RULE_block; } }
            public override void EnterRule(IParseTreeListener listener)
            {
                IPseudoListener typedListener = listener as IPseudoListener;
                if (typedListener != null) typedListener.EnterBlock(this);
            }
            public override void ExitRule(IParseTreeListener listener)
            {
                IPseudoListener typedListener = listener as IPseudoListener;
                if (typedListener != null) typedListener.ExitBlock(this);
            }
            public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor)
            {
                IPseudoVisitor<TResult> typedVisitor = visitor as IPseudoVisitor<TResult>;
                if (typedVisitor != null) return typedVisitor.VisitBlock(this);
                else return visitor.VisitChildren(this);
            }
        }

        [RuleVersion(0)]
        public BlockContext block()
        {
            BlockContext _localctx = new BlockContext(Context, State);
            EnterRule(_localctx, 2, RULE_block);
            int _la;
            try {
                State = 54;
                ErrorHandler.Sync(this);
                switch (TokenStream.LA(1)) {
                    case T__1:
                        EnterOuterAlt(_localctx, 1); {
                            State = 45; Match(T__1);
                            State = 47;
                            ErrorHandler.Sync(this);
                            _la = TokenStream.LA(1);
                            do {
                                {
                                    {
                                        State = 46; statement();
                                    }
                                }
                                State = 49;
                                ErrorHandler.Sync(this);
                                _la = TokenStream.LA(1);
                            } while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << T__3) | (1L << T__4) | (1L << T__5) | (1L << T__6) | (1L << T__9) | (1L << T__11) | (1L << T__13) | (1L << T__14) | (1L << T__15) | (1L << T__17) | (1L << T__20) | (1L << T__41) | (1L << NAME))) != 0));
                            State = 51; Match(T__2);
                        }
                        break;
                    case T__3:
                    case T__4:
                    case T__5:
                    case T__6:
                    case T__9:
                    case T__11:
                    case T__13:
                    case T__14:
                    case T__15:
                    case T__17:
                    case T__20:
                    case T__41:
                    case NAME:
                        EnterOuterAlt(_localctx, 2); {
                            State = 53; statement();
                        }
                        break;
                    default:
                        throw new NoViableAltException(this);
                }
            } catch (RecognitionException re) {
                _localctx.exception = re;
                ErrorHandler.ReportError(this, re);
                ErrorHandler.Recover(this, re);
            } finally {
                ExitRule();
            }
            return _localctx;
        }

        public partial class StatementContext : ParserRuleContext
        {
            public DeclarationContext declaration()
            {
                return GetRuleContext<DeclarationContext>(0);
            }
            public AssignmentContext assignment()
            {
                return GetRuleContext<AssignmentContext>(0);
            }
            public CexpContext cexp()
            {
                return GetRuleContext<CexpContext>(0);
            }
            public ExpContext exp()
            {
                return GetRuleContext<ExpContext>(0);
            }
            public ITerminalNode STRING() { return GetToken(PseudoParser.STRING, 0); }
            public BlockContext[] block()
            {
                return GetRuleContexts<BlockContext>();
            }
            public BlockContext block(int i)
            {
                return GetRuleContext<BlockContext>(i);
            }
            public VarContext var()
            {
                return GetRuleContext<VarContext>(0);
            }
            public StatementContext(ParserRuleContext parent, int invokingState)
                : base(parent, invokingState)
            {
            }
            public override int RuleIndex { get { return RULE_statement; } }
            public override void EnterRule(IParseTreeListener listener)
            {
                IPseudoListener typedListener = listener as IPseudoListener;
                if (typedListener != null) typedListener.EnterStatement(this);
            }
            public override void ExitRule(IParseTreeListener listener)
            {
                IPseudoListener typedListener = listener as IPseudoListener;
                if (typedListener != null) typedListener.ExitStatement(this);
            }
            public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor)
            {
                IPseudoVisitor<TResult> typedVisitor = visitor as IPseudoVisitor<TResult>;
                if (typedVisitor != null) return typedVisitor.VisitStatement(this);
                else return visitor.VisitChildren(this);
            }
        }

        [RuleVersion(0)]
        public StatementContext statement()
        {
            StatementContext _localctx = new StatementContext(Context, State);
            EnterRule(_localctx, 4, RULE_statement);
            int _la;
            try {
                State = 84;
                ErrorHandler.Sync(this);
                switch (TokenStream.LA(1)) {
                    case T__3:
                        EnterOuterAlt(_localctx, 1); {
                            State = 56; Match(T__3);
                        }
                        break;
                    case T__15:
                    case T__17:
                    case T__20:
                        EnterOuterAlt(_localctx, 2); {
                            State = 57; declaration();
                        }
                        break;
                    case NAME:
                        EnterOuterAlt(_localctx, 3); {
                            State = 58; assignment();
                        }
                        break;
                    case T__41:
                        EnterOuterAlt(_localctx, 4); {
                            State = 59; cexp();
                        }
                        break;
                    case T__4:
                        EnterOuterAlt(_localctx, 5); {
                            State = 60; Match(T__4);
                            State = 61; exp(0);
                        }
                        break;
                    case T__5:
                        EnterOuterAlt(_localctx, 6); {
                            State = 62; Match(T__5);
                            State = 63; Match(STRING);
                        }
                        break;
                    case T__6:
                        EnterOuterAlt(_localctx, 7); {
                            State = 64; Match(T__6);
                            State = 65; exp(0);
                            State = 66; Match(T__7);
                            State = 67; block();
                            State = 70;
                            ErrorHandler.Sync(this);
                            switch (Interpreter.AdaptivePredict(TokenStream, 2, Context)) {
                                case 1: {
                                    State = 68; Match(T__8);
                                    State = 69; block();
                                }
                                break;
                            }
                        }
                        break;
                    case T__9:
                        EnterOuterAlt(_localctx, 8); {
                            State = 72; Match(T__9);
                            State = 73; exp(0);
                            State = 74; Match(T__10);
                            State = 75; block();
                        }
                        break;
                    case T__11:
                        EnterOuterAlt(_localctx, 9); {
                            State = 77; Match(T__11);
                            State = 78; block();
                            State = 79; Match(T__12);
                            State = 80; exp(0);
                        }
                        break;
                    case T__13:
                    case T__14:
                        EnterOuterAlt(_localctx, 10); {
                            State = 82;
                            _la = TokenStream.LA(1);
                            if (!(_la == T__13 || _la == T__14)) {
                                ErrorHandler.RecoverInline(this);
                            } else {
                                ErrorHandler.ReportMatch(this);
                                Consume();
                            }
                            State = 83; var();
                        }
                        break;
                    default:
                        throw new NoViableAltException(this);
                }
            } catch (RecognitionException re) {
                _localctx.exception = re;
                ErrorHandler.ReportError(this, re);
                ErrorHandler.Recover(this, re);
            } finally {
                ExitRule();
            }
            return _localctx;
        }

        public partial class DeclarationContext : ParserRuleContext
        {
            public TypeContext type()
            {
                return GetRuleContext<TypeContext>(0);
            }
            public ITerminalNode NAME() { return GetToken(PseudoParser.NAME, 0); }
            public ExpContext exp()
            {
                return GetRuleContext<ExpContext>(0);
            }
            public BlockContext block()
            {
                return GetRuleContext<BlockContext>(0);
            }
            public ParlistContext parlist()
            {
                return GetRuleContext<ParlistContext>(0);
            }
            public DeclarationContext(ParserRuleContext parent, int invokingState)
                : base(parent, invokingState)
            {
            }
            public override int RuleIndex { get { return RULE_declaration; } }
            public override void EnterRule(IParseTreeListener listener)
            {
                IPseudoListener typedListener = listener as IPseudoListener;
                if (typedListener != null) typedListener.EnterDeclaration(this);
            }
            public override void ExitRule(IParseTreeListener listener)
            {
                IPseudoListener typedListener = listener as IPseudoListener;
                if (typedListener != null) typedListener.ExitDeclaration(this);
            }
            public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor)
            {
                IPseudoVisitor<TResult> typedVisitor = visitor as IPseudoVisitor<TResult>;
                if (typedVisitor != null) return typedVisitor.VisitDeclaration(this);
                else return visitor.VisitChildren(this);
            }
        }

        [RuleVersion(0)]
        public DeclarationContext declaration()
        {
            DeclarationContext _localctx = new DeclarationContext(Context, State);
            EnterRule(_localctx, 6, RULE_declaration);
            int _la;
            try {
                State = 112;
                ErrorHandler.Sync(this);
                switch (TokenStream.LA(1)) {
                    case T__15:
                        EnterOuterAlt(_localctx, 1); {
                            State = 86; Match(T__15);
                            State = 87; type();
                            State = 88; Match(NAME);
                            State = 91;
                            ErrorHandler.Sync(this);
                            _la = TokenStream.LA(1);
                            if (_la == T__16) {
                                {
                                    State = 89; Match(T__16);
                                    State = 90; exp(0);
                                }
                            }

                        }
                        break;
                    case T__17:
                        EnterOuterAlt(_localctx, 2); {
                            State = 93; Match(T__17);
                            State = 94; Match(NAME);
                            State = 95; Match(T__18);
                            State = 97;
                            ErrorHandler.Sync(this);
                            _la = TokenStream.LA(1);
                            if (_la == NAME) {
                                {
                                    State = 96; parlist();
                                }
                            }

                            State = 99; Match(T__19);
                            State = 100; block();
                        }
                        break;
                    case T__20:
                        EnterOuterAlt(_localctx, 3); {
                            State = 101; Match(T__20);
                            State = 102; Match(NAME);
                            State = 103; Match(T__18);
                            State = 105;
                            ErrorHandler.Sync(this);
                            _la = TokenStream.LA(1);
                            if (_la == NAME) {
                                {
                                    State = 104; parlist();
                                }
                            }

                            State = 107; Match(T__19);
                            State = 108; Match(T__21);
                            State = 109; type();
                            State = 110; block();
                        }
                        break;
                    default:
                        throw new NoViableAltException(this);
                }
            } catch (RecognitionException re) {
                _localctx.exception = re;
                ErrorHandler.ReportError(this, re);
                ErrorHandler.Recover(this, re);
            } finally {
                ExitRule();
            }
            return _localctx;
        }

        public partial class ParlistContext : ParserRuleContext
        {
            public ITerminalNode[] NAME() { return GetTokens(PseudoParser.NAME); }
            public ITerminalNode NAME(int i)
            {
                return GetToken(PseudoParser.NAME, i);
            }
            public TypeContext[] type()
            {
                return GetRuleContexts<TypeContext>();
            }
            public TypeContext type(int i)
            {
                return GetRuleContext<TypeContext>(i);
            }
            public ParlistContext(ParserRuleContext parent, int invokingState)
                : base(parent, invokingState)
            {
            }
            public override int RuleIndex { get { return RULE_parlist; } }
            public override void EnterRule(IParseTreeListener listener)
            {
                IPseudoListener typedListener = listener as IPseudoListener;
                if (typedListener != null) typedListener.EnterParlist(this);
            }
            public override void ExitRule(IParseTreeListener listener)
            {
                IPseudoListener typedListener = listener as IPseudoListener;
                if (typedListener != null) typedListener.ExitParlist(this);
            }
            public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor)
            {
                IPseudoVisitor<TResult> typedVisitor = visitor as IPseudoVisitor<TResult>;
                if (typedVisitor != null) return typedVisitor.VisitParlist(this);
                else return visitor.VisitChildren(this);
            }
        }

        [RuleVersion(0)]
        public ParlistContext parlist()
        {
            ParlistContext _localctx = new ParlistContext(Context, State);
            EnterRule(_localctx, 8, RULE_parlist);
            int _la;
            try {
                EnterOuterAlt(_localctx, 1);
                {
                    State = 114; Match(NAME);
                    State = 115; Match(T__22);
                    State = 116; type();
                    State = 123;
                    ErrorHandler.Sync(this);
                    _la = TokenStream.LA(1);
                    while (_la == T__23) {
                        {
                            {
                                State = 117; Match(T__23);
                                State = 118; Match(NAME);
                                State = 119; Match(T__22);
                                State = 120; type();
                            }
                        }
                        State = 125;
                        ErrorHandler.Sync(this);
                        _la = TokenStream.LA(1);
                    }
                }
            } catch (RecognitionException re) {
                _localctx.exception = re;
                ErrorHandler.ReportError(this, re);
                ErrorHandler.Recover(this, re);
            } finally {
                ExitRule();
            }
            return _localctx;
        }

        public partial class AssignmentContext : ParserRuleContext
        {
            public VarContext var()
            {
                return GetRuleContext<VarContext>(0);
            }
            public ExpContext exp()
            {
                return GetRuleContext<ExpContext>(0);
            }
            public AssignmentContext(ParserRuleContext parent, int invokingState)
                : base(parent, invokingState)
            {
            }
            public override int RuleIndex { get { return RULE_assignment; } }
            public override void EnterRule(IParseTreeListener listener)
            {
                IPseudoListener typedListener = listener as IPseudoListener;
                if (typedListener != null) typedListener.EnterAssignment(this);
            }
            public override void ExitRule(IParseTreeListener listener)
            {
                IPseudoListener typedListener = listener as IPseudoListener;
                if (typedListener != null) typedListener.ExitAssignment(this);
            }
            public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor)
            {
                IPseudoVisitor<TResult> typedVisitor = visitor as IPseudoVisitor<TResult>;
                if (typedVisitor != null) return typedVisitor.VisitAssignment(this);
                else return visitor.VisitChildren(this);
            }
        }

        [RuleVersion(0)]
        public AssignmentContext assignment()
        {
            AssignmentContext _localctx = new AssignmentContext(Context, State);
            EnterRule(_localctx, 10, RULE_assignment);
            try {
                EnterOuterAlt(_localctx, 1);
                {
                    State = 126; var();
                    State = 127; Match(T__16);
                    State = 128; exp(0);
                }
            } catch (RecognitionException re) {
                _localctx.exception = re;
                ErrorHandler.ReportError(this, re);
                ErrorHandler.Recover(this, re);
            } finally {
                ExitRule();
            }
            return _localctx;
        }

        public partial class ExpContext : ParserRuleContext
        {
            public LiteralContext literal()
            {
                return GetRuleContext<LiteralContext>(0);
            }
            public VarContext var()
            {
                return GetRuleContext<VarContext>(0);
            }
            public ExpContext[] exp()
            {
                return GetRuleContexts<ExpContext>();
            }
            public ExpContext exp(int i)
            {
                return GetRuleContext<ExpContext>(i);
            }
            public UopContext uop()
            {
                return GetRuleContext<UopContext>(0);
            }
            public CexpContext cexp()
            {
                return GetRuleContext<CexpContext>(0);
            }
            public AopContext aop()
            {
                return GetRuleContext<AopContext>(0);
            }
            public RopContext rop()
            {
                return GetRuleContext<RopContext>(0);
            }
            public LopContext lop()
            {
                return GetRuleContext<LopContext>(0);
            }
            public ExpContext(ParserRuleContext parent, int invokingState)
                : base(parent, invokingState)
            {
            }
            public override int RuleIndex { get { return RULE_exp; } }
            public override void EnterRule(IParseTreeListener listener)
            {
                IPseudoListener typedListener = listener as IPseudoListener;
                if (typedListener != null) typedListener.EnterExp(this);
            }
            public override void ExitRule(IParseTreeListener listener)
            {
                IPseudoListener typedListener = listener as IPseudoListener;
                if (typedListener != null) typedListener.ExitExp(this);
            }
            public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor)
            {
                IPseudoVisitor<TResult> typedVisitor = visitor as IPseudoVisitor<TResult>;
                if (typedVisitor != null) return typedVisitor.VisitExp(this);
                else return visitor.VisitChildren(this);
            }
        }

        [RuleVersion(0)]
        public ExpContext exp()
        {
            return exp(0);
        }

        private ExpContext exp(int _p)
        {
            ParserRuleContext _parentctx = Context;
            int _parentState = State;
            ExpContext _localctx = new ExpContext(Context, _parentState);
            ExpContext _prevctx = _localctx;
            int _startState = 12;
            EnterRecursionRule(_localctx, 12, RULE_exp, _p);
            try {
                int _alt;
                EnterOuterAlt(_localctx, 1);
                {
                    State = 141;
                    ErrorHandler.Sync(this);
                    switch (TokenStream.LA(1)) {
                        case T__24:
                        case T__25:
                        case STRING:
                        case INT:
                        case HEX:
                        case FLOAT:
                        case HEX_FLOAT: {
                            State = 131; literal();
                        }
                        break;
                        case NAME: {
                            State = 132; var();
                        }
                        break;
                        case T__18: {
                            State = 133; Match(T__18);
                            State = 134; exp(0);
                            State = 135; Match(T__19);
                        }
                        break;
                        case T__27:
                        case T__40: {
                            State = 137; uop();
                            State = 138; exp(2);
                        }
                        break;
                        case T__41: {
                            State = 140; cexp();
                        }
                        break;
                        default:
                            throw new NoViableAltException(this);
                    }
                    Context.Stop = TokenStream.LT(-1);
                    State = 157;
                    ErrorHandler.Sync(this);
                    _alt = Interpreter.AdaptivePredict(TokenStream, 11, Context);
                    while (_alt != 2 && _alt != global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER) {
                        if (_alt == 1) {
                            if (ParseListeners != null)
                                TriggerExitRuleEvent();
                            _prevctx = _localctx;
                            {
                                State = 155;
                                ErrorHandler.Sync(this);
                                switch (Interpreter.AdaptivePredict(TokenStream, 10, Context)) {
                                    case 1: {
                                        _localctx = new ExpContext(_parentctx, _parentState);
                                        PushNewRecursionContext(_localctx, _startState, RULE_exp);
                                        State = 143;
                                        if (!(Precpred(Context, 5))) throw new FailedPredicateException(this, "Precpred(Context, 5)");
                                        State = 144; aop();
                                        State = 145; exp(6);
                                    }
                                    break;
                                    case 2: {
                                        _localctx = new ExpContext(_parentctx, _parentState);
                                        PushNewRecursionContext(_localctx, _startState, RULE_exp);
                                        State = 147;
                                        if (!(Precpred(Context, 4))) throw new FailedPredicateException(this, "Precpred(Context, 4)");
                                        State = 148; rop();
                                        State = 149; exp(5);
                                    }
                                    break;
                                    case 3: {
                                        _localctx = new ExpContext(_parentctx, _parentState);
                                        PushNewRecursionContext(_localctx, _startState, RULE_exp);
                                        State = 151;
                                        if (!(Precpred(Context, 3))) throw new FailedPredicateException(this, "Precpred(Context, 3)");
                                        State = 152; lop();
                                        State = 153; exp(4);
                                    }
                                    break;
                                }
                            }
                        }
                        State = 159;
                        ErrorHandler.Sync(this);
                        _alt = Interpreter.AdaptivePredict(TokenStream, 11, Context);
                    }
                }
            } catch (RecognitionException re) {
                _localctx.exception = re;
                ErrorHandler.ReportError(this, re);
                ErrorHandler.Recover(this, re);
            } finally {
                UnrollRecursionContexts(_parentctx);
            }
            return _localctx;
        }

        public partial class AexpContext : ParserRuleContext
        {
            public ExpContext[] exp()
            {
                return GetRuleContexts<ExpContext>();
            }
            public ExpContext exp(int i)
            {
                return GetRuleContext<ExpContext>(i);
            }
            public AopContext aop()
            {
                return GetRuleContext<AopContext>(0);
            }
            public AexpContext(ParserRuleContext parent, int invokingState)
                : base(parent, invokingState)
            {
            }
            public override int RuleIndex { get { return RULE_aexp; } }
            public override void EnterRule(IParseTreeListener listener)
            {
                IPseudoListener typedListener = listener as IPseudoListener;
                if (typedListener != null) typedListener.EnterAexp(this);
            }
            public override void ExitRule(IParseTreeListener listener)
            {
                IPseudoListener typedListener = listener as IPseudoListener;
                if (typedListener != null) typedListener.ExitAexp(this);
            }
            public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor)
            {
                IPseudoVisitor<TResult> typedVisitor = visitor as IPseudoVisitor<TResult>;
                if (typedVisitor != null) return typedVisitor.VisitAexp(this);
                else return visitor.VisitChildren(this);
            }
        }

        [RuleVersion(0)]
        public AexpContext aexp()
        {
            AexpContext _localctx = new AexpContext(Context, State);
            EnterRule(_localctx, 14, RULE_aexp);
            try {
                EnterOuterAlt(_localctx, 1);
                {
                    State = 160; exp(0);
                    State = 161; aop();
                    State = 162; exp(0);
                }
            } catch (RecognitionException re) {
                _localctx.exception = re;
                ErrorHandler.ReportError(this, re);
                ErrorHandler.Recover(this, re);
            } finally {
                ExitRule();
            }
            return _localctx;
        }

        public partial class LexpContext : ParserRuleContext
        {
            public ExpContext[] exp()
            {
                return GetRuleContexts<ExpContext>();
            }
            public ExpContext exp(int i)
            {
                return GetRuleContext<ExpContext>(i);
            }
            public LopContext lop()
            {
                return GetRuleContext<LopContext>(0);
            }
            public LexpContext(ParserRuleContext parent, int invokingState)
                : base(parent, invokingState)
            {
            }
            public override int RuleIndex { get { return RULE_lexp; } }
            public override void EnterRule(IParseTreeListener listener)
            {
                IPseudoListener typedListener = listener as IPseudoListener;
                if (typedListener != null) typedListener.EnterLexp(this);
            }
            public override void ExitRule(IParseTreeListener listener)
            {
                IPseudoListener typedListener = listener as IPseudoListener;
                if (typedListener != null) typedListener.ExitLexp(this);
            }
            public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor)
            {
                IPseudoVisitor<TResult> typedVisitor = visitor as IPseudoVisitor<TResult>;
                if (typedVisitor != null) return typedVisitor.VisitLexp(this);
                else return visitor.VisitChildren(this);
            }
        }

        [RuleVersion(0)]
        public LexpContext lexp()
        {
            LexpContext _localctx = new LexpContext(Context, State);
            EnterRule(_localctx, 16, RULE_lexp);
            try {
                State = 170;
                ErrorHandler.Sync(this);
                switch (Interpreter.AdaptivePredict(TokenStream, 12, Context)) {
                    case 1:
                        EnterOuterAlt(_localctx, 1); {
                            State = 164; Match(T__24);
                        }
                        break;
                    case 2:
                        EnterOuterAlt(_localctx, 2); {
                            State = 165; Match(T__25);
                        }
                        break;
                    case 3:
                        EnterOuterAlt(_localctx, 3); {
                            State = 166; exp(0);
                            State = 167; lop();
                            State = 168; exp(0);
                        }
                        break;
                }
            } catch (RecognitionException re) {
                _localctx.exception = re;
                ErrorHandler.ReportError(this, re);
                ErrorHandler.Recover(this, re);
            } finally {
                ExitRule();
            }
            return _localctx;
        }

        public partial class AopContext : ParserRuleContext
        {
            public AopContext(ParserRuleContext parent, int invokingState)
                : base(parent, invokingState)
            {
            }
            public override int RuleIndex { get { return RULE_aop; } }
            public override void EnterRule(IParseTreeListener listener)
            {
                IPseudoListener typedListener = listener as IPseudoListener;
                if (typedListener != null) typedListener.EnterAop(this);
            }
            public override void ExitRule(IParseTreeListener listener)
            {
                IPseudoListener typedListener = listener as IPseudoListener;
                if (typedListener != null) typedListener.ExitAop(this);
            }
            public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor)
            {
                IPseudoVisitor<TResult> typedVisitor = visitor as IPseudoVisitor<TResult>;
                if (typedVisitor != null) return typedVisitor.VisitAop(this);
                else return visitor.VisitChildren(this);
            }
        }

        [RuleVersion(0)]
        public AopContext aop()
        {
            AopContext _localctx = new AopContext(Context, State);
            EnterRule(_localctx, 18, RULE_aop);
            int _la;
            try {
                EnterOuterAlt(_localctx, 1);
                {
                    State = 172;
                    _la = TokenStream.LA(1);
                    if (!((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << T__26) | (1L << T__27) | (1L << T__28) | (1L << T__29) | (1L << T__30) | (1L << T__31))) != 0))) {
                        ErrorHandler.RecoverInline(this);
                    } else {
                        ErrorHandler.ReportMatch(this);
                        Consume();
                    }
                }
            } catch (RecognitionException re) {
                _localctx.exception = re;
                ErrorHandler.ReportError(this, re);
                ErrorHandler.Recover(this, re);
            } finally {
                ExitRule();
            }
            return _localctx;
        }

        public partial class RopContext : ParserRuleContext
        {
            public RopContext(ParserRuleContext parent, int invokingState)
                : base(parent, invokingState)
            {
            }
            public override int RuleIndex { get { return RULE_rop; } }
            public override void EnterRule(IParseTreeListener listener)
            {
                IPseudoListener typedListener = listener as IPseudoListener;
                if (typedListener != null) typedListener.EnterRop(this);
            }
            public override void ExitRule(IParseTreeListener listener)
            {
                IPseudoListener typedListener = listener as IPseudoListener;
                if (typedListener != null) typedListener.ExitRop(this);
            }
            public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor)
            {
                IPseudoVisitor<TResult> typedVisitor = visitor as IPseudoVisitor<TResult>;
                if (typedVisitor != null) return typedVisitor.VisitRop(this);
                else return visitor.VisitChildren(this);
            }
        }

        [RuleVersion(0)]
        public RopContext rop()
        {
            RopContext _localctx = new RopContext(Context, State);
            EnterRule(_localctx, 20, RULE_rop);
            int _la;
            try {
                EnterOuterAlt(_localctx, 1);
                {
                    State = 174;
                    _la = TokenStream.LA(1);
                    if (!((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << T__32) | (1L << T__33) | (1L << T__34) | (1L << T__35) | (1L << T__36) | (1L << T__37))) != 0))) {
                        ErrorHandler.RecoverInline(this);
                    } else {
                        ErrorHandler.ReportMatch(this);
                        Consume();
                    }
                }
            } catch (RecognitionException re) {
                _localctx.exception = re;
                ErrorHandler.ReportError(this, re);
                ErrorHandler.Recover(this, re);
            } finally {
                ExitRule();
            }
            return _localctx;
        }

        public partial class LopContext : ParserRuleContext
        {
            public LopContext(ParserRuleContext parent, int invokingState)
                : base(parent, invokingState)
            {
            }
            public override int RuleIndex { get { return RULE_lop; } }
            public override void EnterRule(IParseTreeListener listener)
            {
                IPseudoListener typedListener = listener as IPseudoListener;
                if (typedListener != null) typedListener.EnterLop(this);
            }
            public override void ExitRule(IParseTreeListener listener)
            {
                IPseudoListener typedListener = listener as IPseudoListener;
                if (typedListener != null) typedListener.ExitLop(this);
            }
            public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor)
            {
                IPseudoVisitor<TResult> typedVisitor = visitor as IPseudoVisitor<TResult>;
                if (typedVisitor != null) return typedVisitor.VisitLop(this);
                else return visitor.VisitChildren(this);
            }
        }

        [RuleVersion(0)]
        public LopContext lop()
        {
            LopContext _localctx = new LopContext(Context, State);
            EnterRule(_localctx, 22, RULE_lop);
            int _la;
            try {
                EnterOuterAlt(_localctx, 1);
                {
                    State = 176;
                    _la = TokenStream.LA(1);
                    if (!(_la == T__38 || _la == T__39)) {
                        ErrorHandler.RecoverInline(this);
                    } else {
                        ErrorHandler.ReportMatch(this);
                        Consume();
                    }
                }
            } catch (RecognitionException re) {
                _localctx.exception = re;
                ErrorHandler.ReportError(this, re);
                ErrorHandler.Recover(this, re);
            } finally {
                ExitRule();
            }
            return _localctx;
        }

        public partial class UopContext : ParserRuleContext
        {
            public UopContext(ParserRuleContext parent, int invokingState)
                : base(parent, invokingState)
            {
            }
            public override int RuleIndex { get { return RULE_uop; } }
            public override void EnterRule(IParseTreeListener listener)
            {
                IPseudoListener typedListener = listener as IPseudoListener;
                if (typedListener != null) typedListener.EnterUop(this);
            }
            public override void ExitRule(IParseTreeListener listener)
            {
                IPseudoListener typedListener = listener as IPseudoListener;
                if (typedListener != null) typedListener.ExitUop(this);
            }
            public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor)
            {
                IPseudoVisitor<TResult> typedVisitor = visitor as IPseudoVisitor<TResult>;
                if (typedVisitor != null) return typedVisitor.VisitUop(this);
                else return visitor.VisitChildren(this);
            }
        }

        [RuleVersion(0)]
        public UopContext uop()
        {
            UopContext _localctx = new UopContext(Context, State);
            EnterRule(_localctx, 24, RULE_uop);
            int _la;
            try {
                EnterOuterAlt(_localctx, 1);
                {
                    State = 178;
                    _la = TokenStream.LA(1);
                    if (!(_la == T__27 || _la == T__40)) {
                        ErrorHandler.RecoverInline(this);
                    } else {
                        ErrorHandler.ReportMatch(this);
                        Consume();
                    }
                }
            } catch (RecognitionException re) {
                _localctx.exception = re;
                ErrorHandler.ReportError(this, re);
                ErrorHandler.Recover(this, re);
            } finally {
                ExitRule();
            }
            return _localctx;
        }

        public partial class CexpContext : ParserRuleContext
        {
            public ITerminalNode NAME() { return GetToken(PseudoParser.NAME, 0); }
            public ExplistContext explist()
            {
                return GetRuleContext<ExplistContext>(0);
            }
            public CexpContext(ParserRuleContext parent, int invokingState)
                : base(parent, invokingState)
            {
            }
            public override int RuleIndex { get { return RULE_cexp; } }
            public override void EnterRule(IParseTreeListener listener)
            {
                IPseudoListener typedListener = listener as IPseudoListener;
                if (typedListener != null) typedListener.EnterCexp(this);
            }
            public override void ExitRule(IParseTreeListener listener)
            {
                IPseudoListener typedListener = listener as IPseudoListener;
                if (typedListener != null) typedListener.ExitCexp(this);
            }
            public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor)
            {
                IPseudoVisitor<TResult> typedVisitor = visitor as IPseudoVisitor<TResult>;
                if (typedVisitor != null) return typedVisitor.VisitCexp(this);
                else return visitor.VisitChildren(this);
            }
        }

        [RuleVersion(0)]
        public CexpContext cexp()
        {
            CexpContext _localctx = new CexpContext(Context, State);
            EnterRule(_localctx, 26, RULE_cexp);
            int _la;
            try {
                EnterOuterAlt(_localctx, 1);
                {
                    State = 180; Match(T__41);
                    State = 181; Match(NAME);
                    State = 182; Match(T__18);
                    State = 184;
                    ErrorHandler.Sync(this);
                    _la = TokenStream.LA(1);
                    if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << T__18) | (1L << T__24) | (1L << T__25) | (1L << T__27) | (1L << T__40) | (1L << T__41) | (1L << NAME) | (1L << STRING) | (1L << INT) | (1L << HEX) | (1L << FLOAT) | (1L << HEX_FLOAT))) != 0)) {
                        {
                            State = 183; explist();
                        }
                    }

                    State = 186; Match(T__19);
                }
            } catch (RecognitionException re) {
                _localctx.exception = re;
                ErrorHandler.ReportError(this, re);
                ErrorHandler.Recover(this, re);
            } finally {
                ExitRule();
            }
            return _localctx;
        }

        public partial class ExplistContext : ParserRuleContext
        {
            public ExpContext[] exp()
            {
                return GetRuleContexts<ExpContext>();
            }
            public ExpContext exp(int i)
            {
                return GetRuleContext<ExpContext>(i);
            }
            public ExplistContext(ParserRuleContext parent, int invokingState)
                : base(parent, invokingState)
            {
            }
            public override int RuleIndex { get { return RULE_explist; } }
            public override void EnterRule(IParseTreeListener listener)
            {
                IPseudoListener typedListener = listener as IPseudoListener;
                if (typedListener != null) typedListener.EnterExplist(this);
            }
            public override void ExitRule(IParseTreeListener listener)
            {
                IPseudoListener typedListener = listener as IPseudoListener;
                if (typedListener != null) typedListener.ExitExplist(this);
            }
            public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor)
            {
                IPseudoVisitor<TResult> typedVisitor = visitor as IPseudoVisitor<TResult>;
                if (typedVisitor != null) return typedVisitor.VisitExplist(this);
                else return visitor.VisitChildren(this);
            }
        }

        [RuleVersion(0)]
        public ExplistContext explist()
        {
            ExplistContext _localctx = new ExplistContext(Context, State);
            EnterRule(_localctx, 28, RULE_explist);
            int _la;
            try {
                EnterOuterAlt(_localctx, 1);
                {
                    State = 188; exp(0);
                    State = 193;
                    ErrorHandler.Sync(this);
                    _la = TokenStream.LA(1);
                    while (_la == T__23) {
                        {
                            {
                                State = 189; Match(T__23);
                                State = 190; exp(0);
                            }
                        }
                        State = 195;
                        ErrorHandler.Sync(this);
                        _la = TokenStream.LA(1);
                    }
                }
            } catch (RecognitionException re) {
                _localctx.exception = re;
                ErrorHandler.ReportError(this, re);
                ErrorHandler.Recover(this, re);
            } finally {
                ExitRule();
            }
            return _localctx;
        }

        public partial class LiteralContext : ParserRuleContext
        {
            public ITerminalNode INT() { return GetToken(PseudoParser.INT, 0); }
            public ITerminalNode HEX() { return GetToken(PseudoParser.HEX, 0); }
            public ITerminalNode FLOAT() { return GetToken(PseudoParser.FLOAT, 0); }
            public ITerminalNode HEX_FLOAT() { return GetToken(PseudoParser.HEX_FLOAT, 0); }
            public ITerminalNode STRING() { return GetToken(PseudoParser.STRING, 0); }
            public LiteralContext(ParserRuleContext parent, int invokingState)
                : base(parent, invokingState)
            {
            }
            public override int RuleIndex { get { return RULE_literal; } }
            public override void EnterRule(IParseTreeListener listener)
            {
                IPseudoListener typedListener = listener as IPseudoListener;
                if (typedListener != null) typedListener.EnterLiteral(this);
            }
            public override void ExitRule(IParseTreeListener listener)
            {
                IPseudoListener typedListener = listener as IPseudoListener;
                if (typedListener != null) typedListener.ExitLiteral(this);
            }
            public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor)
            {
                IPseudoVisitor<TResult> typedVisitor = visitor as IPseudoVisitor<TResult>;
                if (typedVisitor != null) return typedVisitor.VisitLiteral(this);
                else return visitor.VisitChildren(this);
            }
        }

        [RuleVersion(0)]
        public LiteralContext literal()
        {
            LiteralContext _localctx = new LiteralContext(Context, State);
            EnterRule(_localctx, 30, RULE_literal);
            int _la;
            try {
                EnterOuterAlt(_localctx, 1);
                {
                    State = 196;
                    _la = TokenStream.LA(1);
                    if (!((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << T__24) | (1L << T__25) | (1L << STRING) | (1L << INT) | (1L << HEX) | (1L << FLOAT) | (1L << HEX_FLOAT))) != 0))) {
                        ErrorHandler.RecoverInline(this);
                    } else {
                        ErrorHandler.ReportMatch(this);
                        Consume();
                    }
                }
            } catch (RecognitionException re) {
                _localctx.exception = re;
                ErrorHandler.ReportError(this, re);
                ErrorHandler.Recover(this, re);
            } finally {
                ExitRule();
            }
            return _localctx;
        }

        public partial class TypeContext : ParserRuleContext
        {
            public TypenameContext typename()
            {
                return GetRuleContext<TypenameContext>(0);
            }
            public TypeContext(ParserRuleContext parent, int invokingState)
                : base(parent, invokingState)
            {
            }
            public override int RuleIndex { get { return RULE_type; } }
            public override void EnterRule(IParseTreeListener listener)
            {
                IPseudoListener typedListener = listener as IPseudoListener;
                if (typedListener != null) typedListener.EnterType(this);
            }
            public override void ExitRule(IParseTreeListener listener)
            {
                IPseudoListener typedListener = listener as IPseudoListener;
                if (typedListener != null) typedListener.ExitType(this);
            }
            public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor)
            {
                IPseudoVisitor<TResult> typedVisitor = visitor as IPseudoVisitor<TResult>;
                if (typedVisitor != null) return typedVisitor.VisitType(this);
                else return visitor.VisitChildren(this);
            }
        }

        [RuleVersion(0)]
        public TypeContext type()
        {
            TypeContext _localctx = new TypeContext(Context, State);
            EnterRule(_localctx, 32, RULE_type);
            int _la;
            try {
                State = 210;
                ErrorHandler.Sync(this);
                switch (Interpreter.AdaptivePredict(TokenStream, 18, Context)) {
                    case 1:
                        EnterOuterAlt(_localctx, 1); {
                            State = 198; typename();
                            State = 200;
                            ErrorHandler.Sync(this);
                            _la = TokenStream.LA(1);
                            if (_la == T__42) {
                                {
                                    State = 199; Match(T__42);
                                }
                            }

                        }
                        break;
                    case 2:
                        EnterOuterAlt(_localctx, 2); {
                            State = 202; typename();
                            State = 204;
                            ErrorHandler.Sync(this);
                            _la = TokenStream.LA(1);
                            if (_la == T__43) {
                                {
                                    State = 203; Match(T__43);
                                }
                            }

                        }
                        break;
                    case 3:
                        EnterOuterAlt(_localctx, 3); {
                            State = 206; typename();
                            State = 208;
                            ErrorHandler.Sync(this);
                            _la = TokenStream.LA(1);
                            if (_la == T__44) {
                                {
                                    State = 207; Match(T__44);
                                }
                            }

                        }
                        break;
                }
            } catch (RecognitionException re) {
                _localctx.exception = re;
                ErrorHandler.ReportError(this, re);
                ErrorHandler.Recover(this, re);
            } finally {
                ExitRule();
            }
            return _localctx;
        }

        public partial class TypenameContext : ParserRuleContext
        {
            public ITerminalNode NAME() { return GetToken(PseudoParser.NAME, 0); }
            public TypenameContext(ParserRuleContext parent, int invokingState)
                : base(parent, invokingState)
            {
            }
            public override int RuleIndex { get { return RULE_typename; } }
            public override void EnterRule(IParseTreeListener listener)
            {
                IPseudoListener typedListener = listener as IPseudoListener;
                if (typedListener != null) typedListener.EnterTypename(this);
            }
            public override void ExitRule(IParseTreeListener listener)
            {
                IPseudoListener typedListener = listener as IPseudoListener;
                if (typedListener != null) typedListener.ExitTypename(this);
            }
            public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor)
            {
                IPseudoVisitor<TResult> typedVisitor = visitor as IPseudoVisitor<TResult>;
                if (typedVisitor != null) return typedVisitor.VisitTypename(this);
                else return visitor.VisitChildren(this);
            }
        }

        [RuleVersion(0)]
        public TypenameContext typename()
        {
            TypenameContext _localctx = new TypenameContext(Context, State);
            EnterRule(_localctx, 34, RULE_typename);
            int _la;
            try {
                EnterOuterAlt(_localctx, 1);
                {
                    State = 212;
                    _la = TokenStream.LA(1);
                    if (!((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << T__45) | (1L << T__46) | (1L << T__47) | (1L << NAME))) != 0))) {
                        ErrorHandler.RecoverInline(this);
                    } else {
                        ErrorHandler.ReportMatch(this);
                        Consume();
                    }
                }
            } catch (RecognitionException re) {
                _localctx.exception = re;
                ErrorHandler.ReportError(this, re);
                ErrorHandler.Recover(this, re);
            } finally {
                ExitRule();
            }
            return _localctx;
        }

        public partial class VarContext : ParserRuleContext
        {
            public ITerminalNode NAME() { return GetToken(PseudoParser.NAME, 0); }
            public IexpContext iexp()
            {
                return GetRuleContext<IexpContext>(0);
            }
            public VarContext(ParserRuleContext parent, int invokingState)
                : base(parent, invokingState)
            {
            }
            public override int RuleIndex { get { return RULE_var; } }
            public override void EnterRule(IParseTreeListener listener)
            {
                IPseudoListener typedListener = listener as IPseudoListener;
                if (typedListener != null) typedListener.EnterVar(this);
            }
            public override void ExitRule(IParseTreeListener listener)
            {
                IPseudoListener typedListener = listener as IPseudoListener;
                if (typedListener != null) typedListener.ExitVar(this);
            }
            public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor)
            {
                IPseudoVisitor<TResult> typedVisitor = visitor as IPseudoVisitor<TResult>;
                if (typedVisitor != null) return typedVisitor.VisitVar(this);
                else return visitor.VisitChildren(this);
            }
        }

        [RuleVersion(0)]
        public VarContext var()
        {
            VarContext _localctx = new VarContext(Context, State);
            EnterRule(_localctx, 36, RULE_var);
            try {
                EnterOuterAlt(_localctx, 1);
                {
                    State = 214; Match(NAME);
                    State = 219;
                    ErrorHandler.Sync(this);
                    switch (Interpreter.AdaptivePredict(TokenStream, 19, Context)) {
                        case 1: {
                            State = 215; Match(T__48);
                            State = 216; iexp();
                            State = 217; Match(T__49);
                        }
                        break;
                    }
                }
            } catch (RecognitionException re) {
                _localctx.exception = re;
                ErrorHandler.ReportError(this, re);
                ErrorHandler.Recover(this, re);
            } finally {
                ExitRule();
            }
            return _localctx;
        }

        public partial class IexpContext : ParserRuleContext
        {
            public LiteralContext literal()
            {
                return GetRuleContext<LiteralContext>(0);
            }
            public VarContext var()
            {
                return GetRuleContext<VarContext>(0);
            }
            public AexpContext aexp()
            {
                return GetRuleContext<AexpContext>(0);
            }
            public IexpContext(ParserRuleContext parent, int invokingState)
                : base(parent, invokingState)
            {
            }
            public override int RuleIndex { get { return RULE_iexp; } }
            public override void EnterRule(IParseTreeListener listener)
            {
                IPseudoListener typedListener = listener as IPseudoListener;
                if (typedListener != null) typedListener.EnterIexp(this);
            }
            public override void ExitRule(IParseTreeListener listener)
            {
                IPseudoListener typedListener = listener as IPseudoListener;
                if (typedListener != null) typedListener.ExitIexp(this);
            }
            public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor)
            {
                IPseudoVisitor<TResult> typedVisitor = visitor as IPseudoVisitor<TResult>;
                if (typedVisitor != null) return typedVisitor.VisitIexp(this);
                else return visitor.VisitChildren(this);
            }
        }

        [RuleVersion(0)]
        public IexpContext iexp()
        {
            IexpContext _localctx = new IexpContext(Context, State);
            EnterRule(_localctx, 38, RULE_iexp);
            try {
                State = 224;
                ErrorHandler.Sync(this);
                switch (Interpreter.AdaptivePredict(TokenStream, 20, Context)) {
                    case 1:
                        EnterOuterAlt(_localctx, 1); {
                            State = 221; literal();
                        }
                        break;
                    case 2:
                        EnterOuterAlt(_localctx, 2); {
                            State = 222; var();
                        }
                        break;
                    case 3:
                        EnterOuterAlt(_localctx, 3); {
                            State = 223; aexp();
                        }
                        break;
                }
            } catch (RecognitionException re) {
                _localctx.exception = re;
                ErrorHandler.ReportError(this, re);
                ErrorHandler.Recover(this, re);
            } finally {
                ExitRule();
            }
            return _localctx;
        }

        public override bool Sempred(RuleContext _localctx, int ruleIndex, int predIndex)
        {
            switch (ruleIndex) {
                case 6: return exp_sempred((ExpContext)_localctx, predIndex);
            }
            return true;
        }
        private bool exp_sempred(ExpContext _localctx, int predIndex)
        {
            switch (predIndex) {
                case 0: return Precpred(Context, 5);
                case 1: return Precpred(Context, 4);
                case 2: return Precpred(Context, 3);
            }
            return true;
        }

        private static char[] _serializedATN = {
        '\x3', '\x608B', '\xA72A', '\x8133', '\xB9ED', '\x417C', '\x3BE7', '\x7786',
        '\x5964', '\x3', '=', '\xE5', '\x4', '\x2', '\t', '\x2', '\x4', '\x3',
        '\t', '\x3', '\x4', '\x4', '\t', '\x4', '\x4', '\x5', '\t', '\x5', '\x4',
        '\x6', '\t', '\x6', '\x4', '\a', '\t', '\a', '\x4', '\b', '\t', '\b',
        '\x4', '\t', '\t', '\t', '\x4', '\n', '\t', '\n', '\x4', '\v', '\t', '\v',
        '\x4', '\f', '\t', '\f', '\x4', '\r', '\t', '\r', '\x4', '\xE', '\t',
        '\xE', '\x4', '\xF', '\t', '\xF', '\x4', '\x10', '\t', '\x10', '\x4',
        '\x11', '\t', '\x11', '\x4', '\x12', '\t', '\x12', '\x4', '\x13', '\t',
        '\x13', '\x4', '\x14', '\t', '\x14', '\x4', '\x15', '\t', '\x15', '\x3',
        '\x2', '\x3', '\x2', '\x3', '\x2', '\x3', '\x2', '\x3', '\x2', '\x3',
        '\x3', '\x3', '\x3', '\x6', '\x3', '\x32', '\n', '\x3', '\r', '\x3', '\xE',
        '\x3', '\x33', '\x3', '\x3', '\x3', '\x3', '\x3', '\x3', '\x5', '\x3',
        '\x39', '\n', '\x3', '\x3', '\x4', '\x3', '\x4', '\x3', '\x4', '\x3',
        '\x4', '\x3', '\x4', '\x3', '\x4', '\x3', '\x4', '\x3', '\x4', '\x3',
        '\x4', '\x3', '\x4', '\x3', '\x4', '\x3', '\x4', '\x3', '\x4', '\x3',
        '\x4', '\x5', '\x4', 'I', '\n', '\x4', '\x3', '\x4', '\x3', '\x4', '\x3',
        '\x4', '\x3', '\x4', '\x3', '\x4', '\x3', '\x4', '\x3', '\x4', '\x3',
        '\x4', '\x3', '\x4', '\x3', '\x4', '\x3', '\x4', '\x3', '\x4', '\x5',
        '\x4', 'W', '\n', '\x4', '\x3', '\x5', '\x3', '\x5', '\x3', '\x5', '\x3',
        '\x5', '\x3', '\x5', '\x5', '\x5', '^', '\n', '\x5', '\x3', '\x5', '\x3',
        '\x5', '\x3', '\x5', '\x3', '\x5', '\x5', '\x5', '\x64', '\n', '\x5',
        '\x3', '\x5', '\x3', '\x5', '\x3', '\x5', '\x3', '\x5', '\x3', '\x5',
        '\x3', '\x5', '\x5', '\x5', 'l', '\n', '\x5', '\x3', '\x5', '\x3', '\x5',
        '\x3', '\x5', '\x3', '\x5', '\x3', '\x5', '\x5', '\x5', 's', '\n', '\x5',
        '\x3', '\x6', '\x3', '\x6', '\x3', '\x6', '\x3', '\x6', '\x3', '\x6',
        '\x3', '\x6', '\x3', '\x6', '\a', '\x6', '|', '\n', '\x6', '\f', '\x6',
        '\xE', '\x6', '\x7F', '\v', '\x6', '\x3', '\a', '\x3', '\a', '\x3', '\a',
        '\x3', '\a', '\x3', '\b', '\x3', '\b', '\x3', '\b', '\x3', '\b', '\x3',
        '\b', '\x3', '\b', '\x3', '\b', '\x3', '\b', '\x3', '\b', '\x3', '\b',
        '\x3', '\b', '\x5', '\b', '\x90', '\n', '\b', '\x3', '\b', '\x3', '\b',
        '\x3', '\b', '\x3', '\b', '\x3', '\b', '\x3', '\b', '\x3', '\b', '\x3',
        '\b', '\x3', '\b', '\x3', '\b', '\x3', '\b', '\x3', '\b', '\a', '\b',
        '\x9E', '\n', '\b', '\f', '\b', '\xE', '\b', '\xA1', '\v', '\b', '\x3',
        '\t', '\x3', '\t', '\x3', '\t', '\x3', '\t', '\x3', '\n', '\x3', '\n',
        '\x3', '\n', '\x3', '\n', '\x3', '\n', '\x3', '\n', '\x5', '\n', '\xAD',
        '\n', '\n', '\x3', '\v', '\x3', '\v', '\x3', '\f', '\x3', '\f', '\x3',
        '\r', '\x3', '\r', '\x3', '\xE', '\x3', '\xE', '\x3', '\xF', '\x3', '\xF',
        '\x3', '\xF', '\x3', '\xF', '\x5', '\xF', '\xBB', '\n', '\xF', '\x3',
        '\xF', '\x3', '\xF', '\x3', '\x10', '\x3', '\x10', '\x3', '\x10', '\a',
        '\x10', '\xC2', '\n', '\x10', '\f', '\x10', '\xE', '\x10', '\xC5', '\v',
        '\x10', '\x3', '\x11', '\x3', '\x11', '\x3', '\x12', '\x3', '\x12', '\x5',
        '\x12', '\xCB', '\n', '\x12', '\x3', '\x12', '\x3', '\x12', '\x5', '\x12',
        '\xCF', '\n', '\x12', '\x3', '\x12', '\x3', '\x12', '\x5', '\x12', '\xD3',
        '\n', '\x12', '\x5', '\x12', '\xD5', '\n', '\x12', '\x3', '\x13', '\x3',
        '\x13', '\x3', '\x14', '\x3', '\x14', '\x3', '\x14', '\x3', '\x14', '\x3',
        '\x14', '\x5', '\x14', '\xDE', '\n', '\x14', '\x3', '\x15', '\x3', '\x15',
        '\x3', '\x15', '\x5', '\x15', '\xE3', '\n', '\x15', '\x3', '\x15', '\x2',
        '\x3', '\xE', '\x16', '\x2', '\x4', '\x6', '\b', '\n', '\f', '\xE', '\x10',
        '\x12', '\x14', '\x16', '\x18', '\x1A', '\x1C', '\x1E', ' ', '\"', '$',
        '&', '(', '\x2', '\t', '\x3', '\x2', '\x10', '\x11', '\x3', '\x2', '\x1D',
        '\"', '\x3', '\x2', '#', '(', '\x3', '\x2', ')', '*', '\x4', '\x2', '\x1E',
        '\x1E', '+', '+', '\x4', '\x2', '\x1B', '\x1C', '\x36', ':', '\x4', '\x2',
        '\x30', '\x32', '\x35', '\x35', '\x2', '\xF5', '\x2', '*', '\x3', '\x2',
        '\x2', '\x2', '\x4', '\x38', '\x3', '\x2', '\x2', '\x2', '\x6', 'V', '\x3',
        '\x2', '\x2', '\x2', '\b', 'r', '\x3', '\x2', '\x2', '\x2', '\n', 't',
        '\x3', '\x2', '\x2', '\x2', '\f', '\x80', '\x3', '\x2', '\x2', '\x2',
        '\xE', '\x8F', '\x3', '\x2', '\x2', '\x2', '\x10', '\xA2', '\x3', '\x2',
        '\x2', '\x2', '\x12', '\xAC', '\x3', '\x2', '\x2', '\x2', '\x14', '\xAE',
        '\x3', '\x2', '\x2', '\x2', '\x16', '\xB0', '\x3', '\x2', '\x2', '\x2',
        '\x18', '\xB2', '\x3', '\x2', '\x2', '\x2', '\x1A', '\xB4', '\x3', '\x2',
        '\x2', '\x2', '\x1C', '\xB6', '\x3', '\x2', '\x2', '\x2', '\x1E', '\xBE',
        '\x3', '\x2', '\x2', '\x2', ' ', '\xC6', '\x3', '\x2', '\x2', '\x2', '\"',
        '\xD4', '\x3', '\x2', '\x2', '\x2', '$', '\xD6', '\x3', '\x2', '\x2',
        '\x2', '&', '\xD8', '\x3', '\x2', '\x2', '\x2', '(', '\xE2', '\x3', '\x2',
        '\x2', '\x2', '*', '+', '\a', '\x3', '\x2', '\x2', '+', ',', '\a', '\x35',
        '\x2', '\x2', ',', '-', '\x5', '\x4', '\x3', '\x2', '-', '.', '\a', '\x2',
        '\x2', '\x3', '.', '\x3', '\x3', '\x2', '\x2', '\x2', '/', '\x31', '\a',
        '\x4', '\x2', '\x2', '\x30', '\x32', '\x5', '\x6', '\x4', '\x2', '\x31',
        '\x30', '\x3', '\x2', '\x2', '\x2', '\x32', '\x33', '\x3', '\x2', '\x2',
        '\x2', '\x33', '\x31', '\x3', '\x2', '\x2', '\x2', '\x33', '\x34', '\x3',
        '\x2', '\x2', '\x2', '\x34', '\x35', '\x3', '\x2', '\x2', '\x2', '\x35',
        '\x36', '\a', '\x5', '\x2', '\x2', '\x36', '\x39', '\x3', '\x2', '\x2',
        '\x2', '\x37', '\x39', '\x5', '\x6', '\x4', '\x2', '\x38', '/', '\x3',
        '\x2', '\x2', '\x2', '\x38', '\x37', '\x3', '\x2', '\x2', '\x2', '\x39',
        '\x5', '\x3', '\x2', '\x2', '\x2', ':', 'W', '\a', '\x6', '\x2', '\x2',
        ';', 'W', '\x5', '\b', '\x5', '\x2', '<', 'W', '\x5', '\f', '\a', '\x2',
        '=', 'W', '\x5', '\x1C', '\xF', '\x2', '>', '?', '\a', '\a', '\x2', '\x2',
        '?', 'W', '\x5', '\xE', '\b', '\x2', '@', '\x41', '\a', '\b', '\x2', '\x2',
        '\x41', 'W', '\a', '\x36', '\x2', '\x2', '\x42', '\x43', '\a', '\t', '\x2',
        '\x2', '\x43', '\x44', '\x5', '\xE', '\b', '\x2', '\x44', '\x45', '\a',
        '\n', '\x2', '\x2', '\x45', 'H', '\x5', '\x4', '\x3', '\x2', '\x46', 'G',
        '\a', '\v', '\x2', '\x2', 'G', 'I', '\x5', '\x4', '\x3', '\x2', 'H', '\x46',
        '\x3', '\x2', '\x2', '\x2', 'H', 'I', '\x3', '\x2', '\x2', '\x2', 'I',
        'W', '\x3', '\x2', '\x2', '\x2', 'J', 'K', '\a', '\f', '\x2', '\x2', 'K',
        'L', '\x5', '\xE', '\b', '\x2', 'L', 'M', '\a', '\r', '\x2', '\x2', 'M',
        'N', '\x5', '\x4', '\x3', '\x2', 'N', 'W', '\x3', '\x2', '\x2', '\x2',
        'O', 'P', '\a', '\xE', '\x2', '\x2', 'P', 'Q', '\x5', '\x4', '\x3', '\x2',
        'Q', 'R', '\a', '\xF', '\x2', '\x2', 'R', 'S', '\x5', '\xE', '\b', '\x2',
        'S', 'W', '\x3', '\x2', '\x2', '\x2', 'T', 'U', '\t', '\x2', '\x2', '\x2',
        'U', 'W', '\x5', '&', '\x14', '\x2', 'V', ':', '\x3', '\x2', '\x2', '\x2',
        'V', ';', '\x3', '\x2', '\x2', '\x2', 'V', '<', '\x3', '\x2', '\x2', '\x2',
        'V', '=', '\x3', '\x2', '\x2', '\x2', 'V', '>', '\x3', '\x2', '\x2', '\x2',
        'V', '@', '\x3', '\x2', '\x2', '\x2', 'V', '\x42', '\x3', '\x2', '\x2',
        '\x2', 'V', 'J', '\x3', '\x2', '\x2', '\x2', 'V', 'O', '\x3', '\x2', '\x2',
        '\x2', 'V', 'T', '\x3', '\x2', '\x2', '\x2', 'W', '\a', '\x3', '\x2',
        '\x2', '\x2', 'X', 'Y', '\a', '\x12', '\x2', '\x2', 'Y', 'Z', '\x5', '\"',
        '\x12', '\x2', 'Z', ']', '\a', '\x35', '\x2', '\x2', '[', '\\', '\a',
        '\x13', '\x2', '\x2', '\\', '^', '\x5', '\xE', '\b', '\x2', ']', '[',
        '\x3', '\x2', '\x2', '\x2', ']', '^', '\x3', '\x2', '\x2', '\x2', '^',
        's', '\x3', '\x2', '\x2', '\x2', '_', '`', '\a', '\x14', '\x2', '\x2',
        '`', '\x61', '\a', '\x35', '\x2', '\x2', '\x61', '\x63', '\a', '\x15',
        '\x2', '\x2', '\x62', '\x64', '\x5', '\n', '\x6', '\x2', '\x63', '\x62',
        '\x3', '\x2', '\x2', '\x2', '\x63', '\x64', '\x3', '\x2', '\x2', '\x2',
        '\x64', '\x65', '\x3', '\x2', '\x2', '\x2', '\x65', '\x66', '\a', '\x16',
        '\x2', '\x2', '\x66', 's', '\x5', '\x4', '\x3', '\x2', 'g', 'h', '\a',
        '\x17', '\x2', '\x2', 'h', 'i', '\a', '\x35', '\x2', '\x2', 'i', 'k',
        '\a', '\x15', '\x2', '\x2', 'j', 'l', '\x5', '\n', '\x6', '\x2', 'k',
        'j', '\x3', '\x2', '\x2', '\x2', 'k', 'l', '\x3', '\x2', '\x2', '\x2',
        'l', 'm', '\x3', '\x2', '\x2', '\x2', 'm', 'n', '\a', '\x16', '\x2', '\x2',
        'n', 'o', '\a', '\x18', '\x2', '\x2', 'o', 'p', '\x5', '\"', '\x12', '\x2',
        'p', 'q', '\x5', '\x4', '\x3', '\x2', 'q', 's', '\x3', '\x2', '\x2', '\x2',
        'r', 'X', '\x3', '\x2', '\x2', '\x2', 'r', '_', '\x3', '\x2', '\x2', '\x2',
        'r', 'g', '\x3', '\x2', '\x2', '\x2', 's', '\t', '\x3', '\x2', '\x2',
        '\x2', 't', 'u', '\a', '\x35', '\x2', '\x2', 'u', 'v', '\a', '\x19', '\x2',
        '\x2', 'v', '}', '\x5', '\"', '\x12', '\x2', 'w', 'x', '\a', '\x1A', '\x2',
        '\x2', 'x', 'y', '\a', '\x35', '\x2', '\x2', 'y', 'z', '\a', '\x19', '\x2',
        '\x2', 'z', '|', '\x5', '\"', '\x12', '\x2', '{', 'w', '\x3', '\x2', '\x2',
        '\x2', '|', '\x7F', '\x3', '\x2', '\x2', '\x2', '}', '{', '\x3', '\x2',
        '\x2', '\x2', '}', '~', '\x3', '\x2', '\x2', '\x2', '~', '\v', '\x3',
        '\x2', '\x2', '\x2', '\x7F', '}', '\x3', '\x2', '\x2', '\x2', '\x80',
        '\x81', '\x5', '&', '\x14', '\x2', '\x81', '\x82', '\a', '\x13', '\x2',
        '\x2', '\x82', '\x83', '\x5', '\xE', '\b', '\x2', '\x83', '\r', '\x3',
        '\x2', '\x2', '\x2', '\x84', '\x85', '\b', '\b', '\x1', '\x2', '\x85',
        '\x90', '\x5', ' ', '\x11', '\x2', '\x86', '\x90', '\x5', '&', '\x14',
        '\x2', '\x87', '\x88', '\a', '\x15', '\x2', '\x2', '\x88', '\x89', '\x5',
        '\xE', '\b', '\x2', '\x89', '\x8A', '\a', '\x16', '\x2', '\x2', '\x8A',
        '\x90', '\x3', '\x2', '\x2', '\x2', '\x8B', '\x8C', '\x5', '\x1A', '\xE',
        '\x2', '\x8C', '\x8D', '\x5', '\xE', '\b', '\x4', '\x8D', '\x90', '\x3',
        '\x2', '\x2', '\x2', '\x8E', '\x90', '\x5', '\x1C', '\xF', '\x2', '\x8F',
        '\x84', '\x3', '\x2', '\x2', '\x2', '\x8F', '\x86', '\x3', '\x2', '\x2',
        '\x2', '\x8F', '\x87', '\x3', '\x2', '\x2', '\x2', '\x8F', '\x8B', '\x3',
        '\x2', '\x2', '\x2', '\x8F', '\x8E', '\x3', '\x2', '\x2', '\x2', '\x90',
        '\x9F', '\x3', '\x2', '\x2', '\x2', '\x91', '\x92', '\f', '\a', '\x2',
        '\x2', '\x92', '\x93', '\x5', '\x14', '\v', '\x2', '\x93', '\x94', '\x5',
        '\xE', '\b', '\b', '\x94', '\x9E', '\x3', '\x2', '\x2', '\x2', '\x95',
        '\x96', '\f', '\x6', '\x2', '\x2', '\x96', '\x97', '\x5', '\x16', '\f',
        '\x2', '\x97', '\x98', '\x5', '\xE', '\b', '\a', '\x98', '\x9E', '\x3',
        '\x2', '\x2', '\x2', '\x99', '\x9A', '\f', '\x5', '\x2', '\x2', '\x9A',
        '\x9B', '\x5', '\x18', '\r', '\x2', '\x9B', '\x9C', '\x5', '\xE', '\b',
        '\x6', '\x9C', '\x9E', '\x3', '\x2', '\x2', '\x2', '\x9D', '\x91', '\x3',
        '\x2', '\x2', '\x2', '\x9D', '\x95', '\x3', '\x2', '\x2', '\x2', '\x9D',
        '\x99', '\x3', '\x2', '\x2', '\x2', '\x9E', '\xA1', '\x3', '\x2', '\x2',
        '\x2', '\x9F', '\x9D', '\x3', '\x2', '\x2', '\x2', '\x9F', '\xA0', '\x3',
        '\x2', '\x2', '\x2', '\xA0', '\xF', '\x3', '\x2', '\x2', '\x2', '\xA1',
        '\x9F', '\x3', '\x2', '\x2', '\x2', '\xA2', '\xA3', '\x5', '\xE', '\b',
        '\x2', '\xA3', '\xA4', '\x5', '\x14', '\v', '\x2', '\xA4', '\xA5', '\x5',
        '\xE', '\b', '\x2', '\xA5', '\x11', '\x3', '\x2', '\x2', '\x2', '\xA6',
        '\xAD', '\a', '\x1B', '\x2', '\x2', '\xA7', '\xAD', '\a', '\x1C', '\x2',
        '\x2', '\xA8', '\xA9', '\x5', '\xE', '\b', '\x2', '\xA9', '\xAA', '\x5',
        '\x18', '\r', '\x2', '\xAA', '\xAB', '\x5', '\xE', '\b', '\x2', '\xAB',
        '\xAD', '\x3', '\x2', '\x2', '\x2', '\xAC', '\xA6', '\x3', '\x2', '\x2',
        '\x2', '\xAC', '\xA7', '\x3', '\x2', '\x2', '\x2', '\xAC', '\xA8', '\x3',
        '\x2', '\x2', '\x2', '\xAD', '\x13', '\x3', '\x2', '\x2', '\x2', '\xAE',
        '\xAF', '\t', '\x3', '\x2', '\x2', '\xAF', '\x15', '\x3', '\x2', '\x2',
        '\x2', '\xB0', '\xB1', '\t', '\x4', '\x2', '\x2', '\xB1', '\x17', '\x3',
        '\x2', '\x2', '\x2', '\xB2', '\xB3', '\t', '\x5', '\x2', '\x2', '\xB3',
        '\x19', '\x3', '\x2', '\x2', '\x2', '\xB4', '\xB5', '\t', '\x6', '\x2',
        '\x2', '\xB5', '\x1B', '\x3', '\x2', '\x2', '\x2', '\xB6', '\xB7', '\a',
        ',', '\x2', '\x2', '\xB7', '\xB8', '\a', '\x35', '\x2', '\x2', '\xB8',
        '\xBA', '\a', '\x15', '\x2', '\x2', '\xB9', '\xBB', '\x5', '\x1E', '\x10',
        '\x2', '\xBA', '\xB9', '\x3', '\x2', '\x2', '\x2', '\xBA', '\xBB', '\x3',
        '\x2', '\x2', '\x2', '\xBB', '\xBC', '\x3', '\x2', '\x2', '\x2', '\xBC',
        '\xBD', '\a', '\x16', '\x2', '\x2', '\xBD', '\x1D', '\x3', '\x2', '\x2',
        '\x2', '\xBE', '\xC3', '\x5', '\xE', '\b', '\x2', '\xBF', '\xC0', '\a',
        '\x1A', '\x2', '\x2', '\xC0', '\xC2', '\x5', '\xE', '\b', '\x2', '\xC1',
        '\xBF', '\x3', '\x2', '\x2', '\x2', '\xC2', '\xC5', '\x3', '\x2', '\x2',
        '\x2', '\xC3', '\xC1', '\x3', '\x2', '\x2', '\x2', '\xC3', '\xC4', '\x3',
        '\x2', '\x2', '\x2', '\xC4', '\x1F', '\x3', '\x2', '\x2', '\x2', '\xC5',
        '\xC3', '\x3', '\x2', '\x2', '\x2', '\xC6', '\xC7', '\t', '\a', '\x2',
        '\x2', '\xC7', '!', '\x3', '\x2', '\x2', '\x2', '\xC8', '\xCA', '\x5',
        '$', '\x13', '\x2', '\xC9', '\xCB', '\a', '-', '\x2', '\x2', '\xCA', '\xC9',
        '\x3', '\x2', '\x2', '\x2', '\xCA', '\xCB', '\x3', '\x2', '\x2', '\x2',
        '\xCB', '\xD5', '\x3', '\x2', '\x2', '\x2', '\xCC', '\xCE', '\x5', '$',
        '\x13', '\x2', '\xCD', '\xCF', '\a', '.', '\x2', '\x2', '\xCE', '\xCD',
        '\x3', '\x2', '\x2', '\x2', '\xCE', '\xCF', '\x3', '\x2', '\x2', '\x2',
        '\xCF', '\xD5', '\x3', '\x2', '\x2', '\x2', '\xD0', '\xD2', '\x5', '$',
        '\x13', '\x2', '\xD1', '\xD3', '\a', '/', '\x2', '\x2', '\xD2', '\xD1',
        '\x3', '\x2', '\x2', '\x2', '\xD2', '\xD3', '\x3', '\x2', '\x2', '\x2',
        '\xD3', '\xD5', '\x3', '\x2', '\x2', '\x2', '\xD4', '\xC8', '\x3', '\x2',
        '\x2', '\x2', '\xD4', '\xCC', '\x3', '\x2', '\x2', '\x2', '\xD4', '\xD0',
        '\x3', '\x2', '\x2', '\x2', '\xD5', '#', '\x3', '\x2', '\x2', '\x2', '\xD6',
        '\xD7', '\t', '\b', '\x2', '\x2', '\xD7', '%', '\x3', '\x2', '\x2', '\x2',
        '\xD8', '\xDD', '\a', '\x35', '\x2', '\x2', '\xD9', '\xDA', '\a', '\x33',
        '\x2', '\x2', '\xDA', '\xDB', '\x5', '(', '\x15', '\x2', '\xDB', '\xDC',
        '\a', '\x34', '\x2', '\x2', '\xDC', '\xDE', '\x3', '\x2', '\x2', '\x2',
        '\xDD', '\xD9', '\x3', '\x2', '\x2', '\x2', '\xDD', '\xDE', '\x3', '\x2',
        '\x2', '\x2', '\xDE', '\'', '\x3', '\x2', '\x2', '\x2', '\xDF', '\xE3',
        '\x5', ' ', '\x11', '\x2', '\xE0', '\xE3', '\x5', '&', '\x14', '\x2',
        '\xE1', '\xE3', '\x5', '\x10', '\t', '\x2', '\xE2', '\xDF', '\x3', '\x2',
        '\x2', '\x2', '\xE2', '\xE0', '\x3', '\x2', '\x2', '\x2', '\xE2', '\xE1',
        '\x3', '\x2', '\x2', '\x2', '\xE3', ')', '\x3', '\x2', '\x2', '\x2', '\x17',
        '\x33', '\x38', 'H', 'V', ']', '\x63', 'k', 'r', '}', '\x8F', '\x9D',
        '\x9F', '\xAC', '\xBA', '\xC3', '\xCA', '\xCE', '\xD2', '\xD4', '\xDD',
        '\xE2',
    };

        public static readonly ATN _ATN =
            new ATNDeserializer().Deserialize(_serializedATN);


    }
}