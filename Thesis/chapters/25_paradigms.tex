\section{Programske paradigme i gramatičke razlike programskih jezika}
\label{sec:Paradigms}

Iako se u suštini svode na mašinski jezik ili asembler, viši programski jezici mogu imati velike razlike međusobno - kako u načinu pisanja koda, tako i u efikasnosti izvršavanja. Način, ili stil programiranja se naziva \emph{programska paradigma} \cite{ProgrammingParadigms}. Može se pokazati da sve što je rešivo putem jedne, može i da se reši i putem ostalih; međutim neki problemi se prirodnije rešavaju koristeći specifične paradigme. Neke poznatije programske paradigme su navedene u nastavku zajedno sa njihovim odlikama i primerima upotrebe.

\subsection{Imperativna paradigma}
\label{subsec:ParadigmImperative}

\emph{Imperativna paradigma} pretpostavlja da se promene u trenutnom stanju izvršavanja mogu sačuvati kroz promenljive. Izračunavanja se vrše putem niza koraka, u svakom koraku se te promenljive referišu ili se menjaju njihove trenutne vrednosti. Raspored koraka je bitan, jer svaki korak može imati različite posledice s obzirom na trenutne vrednosti promenljivih na početku tog koraka. Primer koda pisanog po imperativnoj paradigmi se može videti na slici \ref{fig:ParadigmImperative}.

\begin{figure}[h!]
\begin{lstlisting}
    result = []
    i = 0
start:
    numPeople = length(people)
    if i >= numPeople goto finished
    p = people[i]
    nameLength = length(p.name)
    if nameLength <= 5 goto nextOne
    upperName = toUpper(p.name)
    addToList(result, upperName)
nextOne:
    i = i + 1
    goto start
finished:
    return sort(result)
\end{lstlisting}
\caption{Primer koda pisanog po imperativnoj paradigmi.}
\label{fig:ParadigmImperative}
\end{figure}

Stariji programski jezici najčešće prate ovu paradigmu više nego bilo koju drugu iz par razloga. Prvi je taj što imperativna paradigma najbliže oslikava samu mašinu na kojoj se program izvršava, pa je programer mnogo "bliži" istoj. Posledica ovog pristupa, a to je i drugi razlog za popularnost imperativne paradigme, je omogućila da je ova paradigma bila najefikasnija zbog ograničenja u hardveru. Danas, zbog mnogo bržeg razvoja i mnogo jačih računara, efikasnost se sve manje i manje uzima u obzir.

Naravno, imperativna paradigma ima i svoje nedostatke. Naime, najveći problem je razumevanje i verifikovanje semantike programa zbog postojanja sporednih efekata \footnote{Sporedni efekti (promena stanja mašine) ne poštuju \emph{referencijalnu transparentnost} koja se definiše na sledeći način: \emph{Ako važi $P(x)$ i $x = y$ u nekom trenutku, onda $P(x) = P(y)$ važi tokom čitavog vremena izvršavanja programa}.}. Stoga je i pronalaženje grešaka u kodovima koji prate imperativnu paradigmu znatno komplikovanije. Apstrakcija je takođe više ograničena u imperativnoj nego u ostalim paradigmama. Na kraju, redosled izvršavanja je vrlo bitan, što neke probleme čini težim ukoliko se pokušaju rešiti pomoću imperativne paradigme.

\subsection{Strukturna paradigma}
\label{subsec:ParadigmImperativeStructural}

\emph{Strukturna paradigma} je vrsta imperativne paradigme gde se kontrola toka vrši putem ugnježdenih petlji, uslovnih grananja i podrutina. Promenljive su obično lokalne za blok u kome su definisane, što određuje i njihov životni vek i vidljivost. Primer koda pisanog po imperativnoj paradigmi se može videti na slici \ref{fig:ParadigmStructural}. Najpopularniji derivat strukturne paradigme je \emph{proceduralna paradigma}, bazirana na konceptu poziva \emph{procedure} - podrutine ili funkcije koja sadrži seriju koraka koje je potrebno izvršiti redom.

\begin{figure}[h!]
\begin{lstlisting}
result = [];
for i = 0; i < length(people); i++ {
    p = people[i];
    if length(p.name)) > 5 {
        addToList(result, toUpper(p.name));
    }
}
return sort(result);
\end{lstlisting}
\caption{Primer koda pisanog po strukturnoj paradigmi.}
\label{fig:ParadigmStructural}
\end{figure}


\subsection{Logička paradigma}
\label{subsec:ParadigmLogical}

\emph{Logička paradigma} koristi deklarativni pristup rešavanju problema. Umesto zadavanja instrukcija koje treba da dovedu do rezultata, opisuje se sam rezultat kroz činjenice - skup logičkih pretpostavki. Taj opis se zatim prevodi u upit koji se dalje koristi. Uloga računara je održavanje i logička dedukcija. Logička paradigma se deli u tri sekcije:
\begin{itemize}
    \item niz deklaracija i definicija koje opisuju problem iz nekog domena,
    \item relevantne činjenice i
    \item relevantni ciljevi u formi upita.
\end{itemize}

Bilo koji rezultat dedukcije rešenja upita predstavlja rezultat izvršavanja. Deklaracije i definicije se konstruišu iz relacija, npr. $X \in Y$ ili $X \in [a,b]$. Prednost ovog pristupa je mala količina programiranja, pošto dedukcioni sistem traži rešenje problema. Takođe, verifikovanje validnosti je stoga trivijalno. Primer koda pisanog po logičkoj paradigmi se može videti na slici \ref{fig:ParadigmLogical}.

\begin{figure}[h!]
\begin{lstlisting}
domains
    being = symbol 
predicates
    animal(being)        % sve životinje su ziva bica
    dog(being)           % svi psi su ziva bica
    die(being)           % svi ziva bica umiru 
clauses
    animal(X) :- dog(X)  % svi psi su zivotinje
    dog(fido).           % fido je pas
    die(X) :- animal(X)  % sve životinje umiru 
\end{lstlisting}
\caption{Primer koda pisanog po logičkoj paradigmi.}
\label{fig:ParadigmLogical}
\end{figure}


\subsection{Funkcionalna paradigma}
\label{subsec:ParadigmFunctional}

\emph{Funkcionalna paradigma} posmatra sve potprograme kao funkcije u matematičkom smislu - uzimaju argumente i vraćaju jedinstven rezultat. Povratna vrednost zavisi isključivo od argumenata, što znači da je nebitan trenutak u kom je funkcija pozvana. Izračunvanja se vrše primenom aplikacije funkcija, kompozicijom funkcija i redukcijom. Primer koda pisanog po funkcionalnoj paradigmi se može videti na slici \ref{fig:ParadigmFunctional}.

\begin{figure}[h!]
\begin{lstlisting}
people 
    |> map    (extract_name . to_upper) 
    |> filter (\name -> length name > 5) 
    |> sort
    |> take 5
    |> join ", "
\end{lstlisting}
\caption{Primer koda pisanog po funkcionalnoj paradigmi.}
\label{fig:ParadigmFunctional}
\end{figure}
    
Funkcionalni programski jezici se baziraju na funkcionalnoj paradigmi. Takvi jezici dozvoljavaju tretiranje funkcija kao \emph{građana prvog reda} - mogu biti tretirane kao podaci pa se mogu proslediti drugim funkcijama ili vratiti kao rezultat izračunavanja drugih funkcija. Prednosti funkcionalnih jezika su visok nivo apstrakcije, što prevazilazi mnogo detalja programiranja i stoga eliminiše pojavu velikog broja grešaka, nezavisnost od redosleda izračunavanja, što omogućava paralelizam, i formalnu matematičku verifikaciju. Mane su potencijalna manja efikasnost, što danas predstavlja manji problem, kao i teškoća implementacije specifične sekvencijalne aktivnosti ili potreba za stanjem, što bi se lako implementiralo imperativno ili preko OO paradigme.


\subsection{Objektno-orijentisana paradigma}
\label{subsec:ParadigmOOP}

\emph{Objektno-orijentisana paradigma} (kraće \emph{OOP}) je paradigma u kojoj se objekti stvarnog sveta posmatraju kao zasebni entiteti koji imaju sopstveno stanje koje se modifikuje samo pomoću procedura ugrađenih u same objekte - tzv. \emph{metode}. Posledica zasebnog operisanja objekata omogućava njihovu enkapsulaciju u module koji sadrže lokalnu sredinu i metode. Komunikacija sa objektom se vrši prosleđivanjem poruka. Objekti su organizovani u klase, od kojih nasleđuju metode i ekvivalentne promenljive. OOP omogućava ponovnu iskorišćenost koda i ekstenzibilnost koda. Primer koda po strukturnoj paradigmi je dat na slici \ref{fig:ParadigmOOP}. 

\begin{figure}[h!]
\begin{lstlisting}
abstract class Employee
{
    private String name;

    Employee(String name) {
        this.name = name;
    }

    abstract void work();
};

class WageEmployee extends Employee
{
    private double wage;
    private double hours;

    WageEmployee(String name) {
        super(name);
        this.name = name;
    }

    void work() {
        wage += 200;
        hours += 8;
    }
};

var bill = new WageEmployee("Bill Gates");
bill.work();
\end{lstlisting}
\caption{Primer koda pisanog po OO paradigmi u programskom jeziku Java.}
\label{fig:ParadigmOOP}
\end{figure}

Nova klasa ($A$) može \emph{naslediti} ili \emph{konkretizovati} drugu klasu ($B$). $B$ se zove \emph{bazna klasa} ili \emph{natklasa}, dok se $A$ naziva \emph{izvedena klasa} ili \emph{potklasa}. Izvedena klasa nasleđuje sve odlike bazne klase - strukturu i ponašanje - postaje specijalizacija bazne klase dok bazna klasa postaje generalizacija svoje potklase. Osim nasleđenih osobina, potklasa može imati dodatna stanja (instancne promenljive) ili dodatna ponašanja (metode). Dozvoljeno je i predefinisanje ponašanja bazne klase. Mehanizam nasleđivanja je dozvoljen i ukoliko nije dozvoljen pristup izvornom kodu bazne klase.

Idealno, stanju objekta može da pristupi i modifikuje samo pomoću metoda tog objekta. Većina OO jezika dozvoljava direktnu manipulaciju stanja ali taj pristup nije preporučen. Kako bi se enkapsulacija i skrivanje informacija kao najveće prednosti OO paradigme mogle iskoristiti, interfejs klase (kako se pristupa objektima) bi trebalo da bude odvojen od implementacije klase (izvornog koda metoda klasa).


\subsection{Skript paradigma i njen odnos sa proceduralnom paradigmom}
\label{subsec:Languages}

Čak i unutar jedne paradigme kao što je proceduralna, mogu se naći veoma velike varijacije u izgledu koda pisanog u različitim programskim jezicima koji prate proceduralnu paradigmu. Kako hardver postaje moćniji, više se ceni vreme koje programer provede u procesu pisanja koda nego koliko je taj kod efikasan. Štaviše, u nekim slučajevima je dobitak u efikasnosti veoma mali u poređenju sa vremenom koje je potrebno utrošiti da bi se ta efikasnost postigla. Ukoliko se program pokreće veoma retko, možda nije ni bitno da li se on izvršava sekundu sporije od efikasnog programa, ako je za njegovo pisanje utrošeno znatno manje vremena. Ovo je pristup koji prate \emph{skript} jezici kao što su \texttt{Python, Perl, bash} itd. Iako proceduralni, oni se razlikuju od klasičnih predstavnika proceduralne paradigme i njihove razlike su vremenom postale tolike da nije neuobičajeno da se skript jezici svrstaju u zasebnu, \emph{skript paradigmu}. Stoga će se u nastavku, pod terminom \emph{proceduralni jezik} smatrati tradicionalni proceduralni jezik, ukoliko nije naznačeno drugačije. Na slici \ref{fig:LanguagesDiff} se mogu uočiti navedene razlike.

\begin{figure}[h!]
\begin{lstlisting}
int main() {
    int k = 0;
    for (int i = 0; i < 1000000; i++)
        k++;
    return 0;
}
\end{lstlisting}
\begin{lstlisting}[language={}]
$ time: 0.03s user 0.00s system 70% cpu 0.044 total
\end{lstlisting}
\begin{lstlisting}
k = 0
for i in range(1000000):
    k += 1
\end{lstlisting}
\begin{lstlisting}[language={}]
$ time: 0.16s user 0.03s system 93% cpu 0.200 total
\end{lstlisting}
\caption{Primer koda pisanog po tradicionalnoj proceduralnoj paradigmi (gore, \texttt{C}) i po modernoj skript paradigmi (gore, \texttt{Python 3}) kao i odgovarajuća vremena izvršavanja dobijena komandom \texttt{time}.}
\label{fig:LanguagesDiff}
\end{figure}

Promenljive predstavljaju jedan od osnovnih koncepata na kojem se zasnivaju i proceduralni i skript jezici. Promenljivu odlikuje, između ostalog, i njen \emph{tip} koji određuje količinu memorije potrebnu za njeno skladištenje. Proceduralni programski jezici zahtevaju definisanje tipa promenljive i obično su i \emph{statički}, što znači da promenljive ne mogu menjati svoj tip tokom izvršavanja programa. Proces uvođenja imena promenljive se u naziva \emph{deklaracija promenljive}. Slično kao i za promenljive, potrebno je deklarisati i funkcije pre trenutka njihovog korišćenja kako bi prevodilac znao broj i tipove parametara funkcije kao i njihove povratne vrednosti. Skript jezici žrtvuju strogu tipiziranost kako bi proces pisanja koda bio brži. Stoga su oni obično \emph{dinamički} - promenljive mogu menjati tip tokom izvršavanja programa. Pošto promenljive mogu menjati svoj tip, definisanje tipa prilikom uvođenja imena promenljive postaje redundantno jer prevodilac može to sam da zaključi. Stoga i sam proces uvođenja imena promenljive postaje redundantan. Slično, parametri funkcija takođe nisu fiksnog tipa. Slično važi i za povratnu vrednost funkcije.

Kod proceduralnih jezika, pošto su obično strogo tipizirani, mogu se iskoristiti strukture podataka koje omogućavaju brz pristup svojim elementiram. To su obično nizovi koji predstavljaju kontinualni blok memorije u kom su elementi niza smešteni jedan do drugog. Pristup se vrši na osnovu indeksa i, pošto su svi elementi istog tipa (zauzimaju jednaku količinu memorije), može se u konstantnom vremenu izračunati memorijska lokacija na kojoj se nalazi element niza sa datim indeksom. Kompleksnije strukture podataka obično nisu podržane u samom jeziku. Neki proceduralni jezici dozvoljavaju veoma niski pristup kroz \emph{pokazivače} ili \emph{reference} na memorijske adrese (\texttt{C} i \texttt{C++}). Većina modernih proceduralnih jezika ne dozvoljava rad sa pokazivačima, ne brinući puno o efikasnosti, dok neki dozvoljavaju korišćenje pokazivača u specijalnim situacijama sa eksplicitnom naznakom (\texttt{C\#}).

Pored dinamičnosti kad je u pitanju tip promenljivih, skript jezici često imaju neke specifične strukture podataka ugrađene u sam jezik kao olakšice prilikom programiranja. Primarna struktura podataka je \emph{jednostruko ulančana lista} \footnote{Lista je rekurzivna kolekcija podataka koja se sastoji od glave koja sadrži vrednost određenog tipa, i pokazivača na rep - drugu listu. Specijalno, praznim pokazivačima se označava kraj liste (prazna lista).}, za razliku od niza kod proceduralnih jezika. Razlog zašto se koriste liste je delimično zbog toga što, kao i ostale promenljive, liste nisu strogo tipizirane. Moguće je u listu ubacivati elemente različitih tipova - što onemogućava skladištenje u kontinualnom bloku memorije (osim ukoliko je lista imutabilna, što nije obično slučaj). Skript jezici uglavnom omogućavaju indeksni pristup elementima liste pa programeru izgleda kao da radi nad običnim nizom. Neki skript jezici omogućavaju kreiranje \emph{asocijativnih nizova}, gde indeks niza ne mora biti ceo broj već može uzimati vrednost iz domena bilo kog tipa. Osim listi, obično su podržane i torke, i za njih važe iste slobode kao i za liste. Kompleksnije strukture podataka uključuju skupove i rečnike (drugačije nazivane i \emph{heš mape}, engl. \emph{hash map}) koji su kolekcija ključ-vrednost parova gde je dozvoljen indeksni pristup po vrednosti ključa. Skript programski jezici su skoro uvek interpretirani, iako se neki jezici mogu kompajlirati po potrebi za efikasnije ponovno izvršavanje. S obzirom da efikasnost nije u glavnom planu, u skript jezicima nije dozvoljen direktan pristup memoriji putem pokazivača ili referenci. 

