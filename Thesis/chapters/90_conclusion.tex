\chapter{Zaključak}
\label{chp:conclusion}

Kako softver postaje složeniji i hardver se sve više razvija, potreba za pouzdanim verifikacionim alatima postaje sve veća i uzima sve veći značaj u procesu razvoja softvera. Održavanje koda je najduža faza u razvoju softvera i prilikom održavanja koda se vrše refaktorisanja koja ne menjaju puno izvorni kod. Ponekad je potrebno i prepisati izvorni kod sa jednog programskog jezika na drugi. U svim ovim situacijama je moguće izvršiti semantičko poređenje s obzirom da struktura koda ostaje pretežno ista. 

U tezi je opisan način posmatranja apstrakne sintakse programa kroz AST, opisan je proces kreiranja AST od proizvoljne gramatike programskog jezika i opšte-prihvaćen interfejs za obilazak istog. Opisan je model opšte AST apstrakcije sa ciljem dovođenja imperativnih i skript jezika na isti nivo apstrakcije. Ova apstrakcija je korišćena za određivanje semantičke ekvivalentnosti strukturno sličnih segmenata koda kroz naivni algoritam poređenja vrednosti na krajevima blokova.

Kao glavni doprinos teze, implementiran je računarski program za kreiranje opšteg AST od izvornog fajla, serijalizaciju i prikaz istog. Mehanizam dobijanja opšteg AST omogućava jednostavno proširenje za već postojeće ali i za proizvoljne gramatike, kroz implementaciju adaptera za tu gramatiku koji služi kao posrednik između stabla parsiranja i opšteg AST. Dodatno, kao jedna primena opšte AST apstrakcije, implementiran je opisani algoritam za semantičko poređenje kroz proširiv model upoređivača tipova opštih AST čvorova.

Naredni koraci u dizajniranju modela opšte apstrakcije bi bili usmereni na podršku za korisnički definisane tipove kroz čvorove za opis klasa, struktura i enumeracija. Takođe, klase se u skript jezicima često izbegavaju tako što se podaci smeste u mapu gde ključevi imitiraju atribute klase. Stoga bi bilo poželjno imati i interfejs za kreiranje mape objekta od datog klasnog čvora ali i obrnuto. Osim korisnički definisanih tipova, oseća se i potreba za apstrahovanjem čestih struktura podataka kao što su skupovi, torke i redovi sa prioritetom. Na taj način, ako se u jednom programu koristi niz a u drugom jednostruko ulančana lista sa definisanim indeksnim pristupom, moguće je posmatrati te programe kao jednake uz potencijalno upozorenje o gubitku na efikasnosti. U planu je i proširivanje modela tako da se uključe i druge programske paradigme osim imperativne.

