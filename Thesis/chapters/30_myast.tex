\chapter{Zajednička AST apstrakcija za imperativne jezike}
\label{chp:MyAST}

Kao što je opisano u odeljku \ref{sec:Paradigms}, dosta različitih "pod-paradigmi" potiče iz imperativne paradigme. Strukturna, proceduralna i skript paradigma, iako naizgled različite, poseduju veliki broj sličnih osobina i koncepata. Svaki programski jezik ima svoju gramatiku i na osnovu toga ima svoja gramatička pravila koja se oslikavaju u apstraktnim sintaksnim stablima tih jezika. Na slikama \ref{fig:ASTLua} i \ref{fig:ASTGo} se mogu videti razlike u strukturi AST-a za jezike \texttt{Lua} i \texttt{Go}, kao primeri skript odnosno proceduralne paradigme.

\begin{figure}[h!]
    \centering
        \includegraphics[scale=0.6]{images/ast_lua.png}
    \caption{Prikaz AST-a isečka koda pisanog u programskom jeziku Lua. Prikazano putem \url{https://astexplorer.net/}}
    \label{fig:ASTLua}
\end{figure}

\begin{figure}[h!]
    \centering
        \includegraphics[scale=0.7]{images/ast_go.png}
    \caption{Prikaz AST-a isečka koda pisanog u programskom jeziku Go. Prikazano putem \url{https://astexplorer.net/}}
    \label{fig:ASTGo}
\end{figure}

U ovoj poglavlju će biti predstavljena AST apstrakcija dizajnirana tako da je uz pomoć nje moguće predstaviti kodove proizvoljnog imperativnog programskog jezika. To uključuje i skript jezike koji, kako će biti pokazano u ovom radu, mogu da se posmatraju na istom nivou kao i svoji proceduralni "rođaci".

Kako bi se kreirala smislena apstrakcija stabla parsiranja, potrebno je identifikovati bitne informacije u stablu parsiranja ali i koncepte same gramatike koji su od značaja. Najjednostavnije rešenje je mimikovati čvorove stabla parsiranja, ukoliko su gramatička pravila kreirana tako da oslikaju koncepte jezika koji gramatika definiše. Na primer, ukoliko u gramatici imamo pravilo \texttt{deklaracija} sa alternativama \texttt{deklaracijaPromenljive} i \texttt{deklaracijaFunkcije}, možemo kreirati apstraktni koncept \texttt{Deklaracija} sa konkretizacijama \texttt{DeklaracijaPromenljive} i \texttt{DeklaracijaFunkcije}. Kako se definišu deklaracije promenljivih i funkcija zavisi dalje od definicija pravila \texttt{deklaracijaPromenljive} i \texttt{deklaracijaFunkcije}. Naravno, nije uvek moguće primeniti ovakav postupak. Takođe, nekada u gramatici definišemo pomoćna pravila kako bismo se izborili sa rekurzijom ili izbegli neke tipove rekurzije - ta pravila ne bi trebalo da imaju odgovarajuće tipove u apstrakciji. 

Pošto su u pitanju gramatike programskih jezika, onda je jasno da dosta različitih gramatika dele slične koncepte i da je moguće definisati tipove čvorova koji odgovaraju tim konceptima. Neki od njih mogu biti: naredba, izraz, deklaracija, poziv funkcije, dodela... Jasno, postoji i hijerarhija između navedenih koncepata - poziv funkcije se može smatrati kao samostalna naredba ali može biti i deo izraza. Dakle, treba biti jako pažljiv u definisanju hijerarhije tako da ne dozvoli nešto što u opštem slučaju ne bi trebalo da bude dozvoljeno (npr. ako je dozvoljeno višestruko nasleđivanje i poziv funkcije je i naredba ali i izraz, onda se izrazi u kojima figurišu pozivi funkcija sastoje od više naredbi, što nema smisla.).

Osim naredbi i izraza (koje vezuju operatori), kao osnovnih koncepata imperativnih jezika, deklaracije se ne pojavljuju u skript jezicima. Moguće je, međutim, posmatrati i promenljive u kodovima skript jezika kao promenljive deklarisane pre trenutka njihove upotrebe - detaljnije opisano u \ref{sec:MyASTDeclarationNodes}. Što se tiče njihovog tipa, može biti dozvoljena promena istog, ili, kako je izabrano u ovom radu, biće iskorišćen specijalni tip od kog potiču svi ostali tipovi.

\begin{figure}[h!]
    \centering
        \includegraphics[scale=0.7]{images/nodes.png}
    \caption{Prikaz osnovnih vrsta AST čvorova.}
    \label{fig:ASTNode}
\end{figure}

Na slici \ref{fig:ASTNode} se mogu videti osnovni tipovi AST čvorova zasnovani na konceptima opisanim iznad. U nastavku će po odeljcim biti detaljnije opisan svaki od tipova AST čvorova sa slike.

\input{chapters/31_declaration_nodes.tex}
\input{chapters/32_operator_nodes.tex}
\input{chapters/33_expression_nodes.tex}
\input{chapters/34_statement_nodes.tex}
\input{chapters/34_example.tex}
