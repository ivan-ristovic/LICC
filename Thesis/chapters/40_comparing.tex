\section{Čvorovi naredbi}
\label{sec:MyASTStatementNodes}


\iffalse
Bez obzira na to koje koncepte izdvojimo iz stabla parsiranja kao relevantne, potrebno ih je sve unifikovati. Slično kao što svi čvorovi stabla parsiranja moraju biti derivati određene klase (pošto svi elementi stabla moraju biti istog tipa), isto treba da važi i za apstraktno sintaksno stablo. Stoga, postojaće apstraktna bazna klasa sa informacijama koje svaki čvor AST-a poseduje. Ova bazna klasa će u nastavku rada biti referisana kao \texttt{ASTNode}. Pošto je AST stablo u kome svaki čvor može imati proizvoljno mnogo potomaka, očekivano je da svaki čvor ima pokazivače na potomke gde svaki pokazivač pokazuje na objekat tipa \texttt{ASTNode} (jasno, ne možemo napraviti objekat klase \texttt{ASTNode} jer je klasa apstraktna ali konkretizacije klase \texttt{ASTNode} su takođe tipa \texttt{ASTNode}). Radi jednostavnosti implementacije nekih operacija biće dodatno dostupna informacija o roditelju svakog čvora putem pokazivača na roditelja, tipa \texttt{ASTNode} - koreni čvor neće imati postavljenu vrednost ovog polja. Dodatne informacije recimo mogu biti linija u izvornom fajlu gde se nalazi kod koji odgovara čvoru. Dodatno, možemo definisati i metode koje treba svaki čvor da poseduje - recimo metode za serijalizaciju \footnote{Serijalizacija predstavlja proces konvertovanja stanja objekta u niz bajtova da bi se isti sačuvao u bazu podataka, fajl, ili pak prosledio nekom drugom programu.}. 

\begin{figure}[h!]
    \centering
        \includegraphics[scale=0.9]{images/c_code_decomposition.png}
    \caption{Vizualni prikaz delova C koda na osnovu pravila iz C11 gramatike.}
    \label{fig:CDecomposition}
\end{figure}

Krenućemo od gramatika strogo tipiziranih proceduralnih programskih jezika, a zatim ćemo koncepte proširiti i na skript jezie. U strogo tipiziranim proceduralnim jezicima se mogu identifikovati koncepti koji se pojavljuju u većini od njih. Na primeru C koda sa slike \ref{fig:CDecomposition} moguće je videti neke od njih. Koncepti naredbe i izraza su očigledni i nisu prikazani. Nije očigledno, doduše, kako bi se deklaracija promenljive dekomponovala na delove. Po C11 gramatici, svaka deklaracija se sastoji od \emph{specifikatora deklaracije} i od jednog ili više \emph{deklaratora}. Specifikatori deklaracije su ključne reči koje bliže određuju deklaraciju - modifikatori vidljivosti ili specifikatori pristupa. Deklaratori uvode simbol (\emph{identifikator}) u kontekst kao promenljivu, niz ili funkciju. Deklaratori, u zavisnosti od toga šta se deklariše, mogu imati razne delove. Ukoliko je u pitanju deklarator promenljive, sastoje se i od opcionog izraza za inicijalizaciju, u daljem tekstu \emph{inicijalizator}. Ukoliko je u pitanju deklarator funkcije, nakon identifikatora se nalazi lista parametara funkcije - svaki od njih se sastoji od specifikatora deklaracije i deklaratora.

\begin{figure}[h!]
    \centering
        \includegraphics[scale=0.7]{images/uml/ASTNode.jpg}
    \caption{UML klasni dijagram direktnih derivata klase \texttt{ASTNode}.}
    \label{fig:UMLASTNode}
\end{figure}

Ovakvi koncepti će biti inspiracija za definisanje AST čvorova, pri čemu će detaljno biti opisana motivacija i razlozi za odabir nekih specifičnosti. Na slici \ref{fig:UMLASTNode} se mogu videti osnovni apstraktni derivate klase \texttt{ASTNode}. Jedini direktna konkretizacija klase \texttt{ASTNode} koja nije apstraktna je klasa \texttt{SourceComponentNode}. Svrha ove klase je da označi granice izvornih fajlova u slučaju da se pravi AST od više različitih izvornih fajlova - stoga će koren svakog AST-a kreiranog od izvornog fajla biti tipa \texttt{SourceComponentNode} \footnote{Navedeno važi pod pretpostavkom da se stablo parsiranja čitavog izvornog fajla prevodi u AST. Biće dozvoljeno i prevođenje delova izvornog fajla, u kom slučaju koren AST-a neće biti tipa \texttt{SourceComponentNode}.}. U nastavku će biti detaljno opisane apstraktne konkretizacije klase \texttt{ASTNode} sa slike \ref{fig:UMLASTNode} zajedno sa svojim derivatima. 
\endif